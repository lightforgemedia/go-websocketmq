Okay, this is a significant but exciting refactoring! We're aiming to make `go-websocketmq` much more powerful for direct client-server RPC while retaining its pub/sub capabilities.

I'll proceed by re-implementing the library components first, incorporating the new capabilities, and then build the example project.

**Phase 1: Core Library Enhancements (`go-websocketmq`)**

**File: pkg/model/message.go**
```go
// pkg/model/message.go
// Package model defines the core message types and structures used in WebSocketMQ.
//
// This package provides the Message and MessageHeader types that form the foundation
// of the messaging system, along with factory functions for creating different
// types of messages (events, requests, and responses).
package model

import (
	"time"
)

// MessageHeader contains metadata and routing information for a message.
// Headers include identifiers, timing information, and routing details.
type MessageHeader struct {
	// MessageID is a unique identifier for this specific message.
	MessageID string `json:"messageID"`
	
	// CorrelationID links related messages together, particularly
	// for request-response pairs where the response includes the
	// same correlation ID as the original request.
	CorrelationID string `json:"correlationID,omitempty"`
	
	// Type indicates the message purpose: "event", "request", or "response".
	// Events are one-way notifications, while requests expect responses.
	Type string `json:"type"`
	
	// Topic is the publish/subscribe channel for this message.
	// For RPC-style requests initiated by the server to a specific client,
	// this topic will often represent the "action name" or "procedure name".
	Topic string `json:"topic"`
	
	// Timestamp records when the message was created (milliseconds since epoch).
	Timestamp int64 `json:"timestamp"`
	
	// TTL (Time To Live) indicates how long a request should wait for a response
	// in milliseconds before timing out. Only used for request messages.
	TTL int64 `json:"ttl,omitempty"`

	// SourceBrokerClientID is an optional field that can be used internally by the server
	// to identify the origin connection of a message received from a client.
	// It is typically not set by clients or for server-to-client messages.
	SourceBrokerClientID string `json:"-"` // Ignored by JSON, for internal use
}

// Message is the core data structure that flows through the WebSocketMQ system.
// Each message contains a header with routing information and a body with
// the actual payload data.
type Message struct {
	// Header contains metadata and routing information for the message.
	Header MessageHeader `json:"header"`
	
	// Body contains the actual message payload, which can be any JSON-serializable value.
	Body any `json:"body"`
}

// NewEvent creates a new event message for the specified topic.
func NewEvent(topic string, body any) *Message {
	return &Message{
		Header: MessageHeader{
			MessageID: randomID(),
			Type:      "event",
			Topic:     topic,
			Timestamp: time.Now().UnixMilli(),
		},
		Body: body,
	}
}

// NewRequest creates a new request message with a correlation ID for responses.
// For server-to-client RPC, 'topic' will be the action/procedure name.
func NewRequest(topic string, body any, timeoutMs int64) *Message {
	correlationID := randomID()
	return &Message{
		Header: MessageHeader{
			MessageID:     randomID(),
			CorrelationID: correlationID,
			Type:          "request",
			Topic:         topic, // For RPC, this is the action name
			Timestamp:     time.Now().UnixMilli(),
			TTL:           timeoutMs,
		},
		Body: body,
	}
}

// NewResponse creates a response message for a received request.
// The response Topic is set to the original request's CorrelationID.
func NewResponse(req *Message, body any) *Message {
	return &Message{
		Header: MessageHeader{
			MessageID:     randomID(),
			CorrelationID: req.Header.CorrelationID,
			Type:          "response",
			Topic:         req.Header.CorrelationID, // Publish to the correlation ID topic
			Timestamp:     time.Now().UnixMilli(),
		},
		Body: body,
	}
}

// NewErrorMessage creates a specialized response indicating an error.
func NewErrorMessage(req *Message, errorBody any) *Message {
	return &Message{
		Header: MessageHeader{
			MessageID:     randomID(),
			CorrelationID: req.Header.CorrelationID,
			Type:          "error", // Specific type for errors
			Topic:         req.Header.CorrelationID,
			Timestamp:     time.Now().UnixMilli(),
		},
		Body: errorBody,
	}
}


// randomID generates a unique identifier for messages.
func randomID() string {
	// Simple ID, consider UUID for production robustness if collisions are a concern.
	return fmt.Sprintf("%d-%d", time.Now().UnixNano(), pseudoRand.Int63())
}

// For randomID to avoid dependency on math/rand's global state and ensure some randomness.
// Not cryptographically secure, just for unique IDs.
import (
	"crypto/rand"
	"encoding/binary"
	"fmt"
	mrand "math/rand"
	"sync"
)

var (
	pseudoRand *mrand.Rand
	once       sync.Once
)

func initRandom() {
	var seed int64
	err := binary.Read(rand.Reader, binary.LittleEndian, &seed)
	if err != nil {
		// Fallback to time-based seed if crypto/rand fails
		seed = time.Now().UnixNano()
	}
	pseudoRand = mrand.New(mrand.NewSource(seed))
}

func init() {
	once.Do(initRandom)
}

```

**File: pkg/broker/broker.go**
```go
// pkg/broker/broker.go
package broker

import (
	"context"
	"errors"
	"time"

	"github.com/lightforgemedia/go-websocketmq/pkg/model"
)

// Predefined error types
var (
	ErrClientNotFound      = errors.New("client not found")
	ErrRequestTimeout      = errors.New("request timed out")
	ErrConnectionWrite     = errors.New("connection write error")
	ErrBrokerClosed        = errors.New("broker is closed")
	ErrInvalidMessage      = errors.New("invalid message")
)

// Constants for internal broker events
const (
	// TopicClientRegistered is published when a client registers its PageSessionID.
	// Body: map[string]string{"pageSessionID": "...", "brokerClientID": "..."}
	TopicClientRegistered = "_internal.client.registered"

	// TopicClientDeregistered is published when a client connection is deregistered from the broker.
	// Body: map[string]string{"brokerClientID": "..."}
	TopicClientDeregistered = "_internal.client.deregistered"
)


// Logger defines the interface for logging messages.
type Logger interface {
	Debug(msg string, args ...any)
	Info(msg string, args ...any)
	Warn(msg string, args ...any)
	Error(msg string, args ...any)
}

// MessageHandler is a function type that processes messages.
// For requests, returning a non-nil *model.Message will be sent as a response.
// The sourceBrokerClientID is provided if the message originated from a known client connection.
type MessageHandler func(ctx context.Context, msg *model.Message, sourceBrokerClientID string) (*model.Message, error)

// ConnectionWriter defines an interface for writing messages to a specific connection.
// This is used by the broker to send messages to individual WebSocket clients.
type ConnectionWriter interface {
	WriteMessage(ctx context.Context, msg *model.Message) error
	BrokerClientID() string
	Close() error // Close the underlying connection
}

// Broker defines the interface for message routing.
type Broker interface {
	// Publish sends a message to all subscribers of the message's topic.
	Publish(ctx context.Context, msg *model.Message) error

	// Subscribe registers a handler for a specific topic.
	// The sourceBrokerClientID in the MessageHandler will be empty for messages not originating from a client connection.
	Subscribe(ctx context.Context, topic string, handler MessageHandler) error
	
	// Unsubscribe removes a handler for a specific topic.
	// This is more complex to implement correctly with anonymous handlers.
	// For simplicity, we might rely on context cancellation for cleanup or require named subscriptions.
	// Unsubscribe(ctx context.Context, topic string, handler MessageHandler) error // TODO: Consider how to implement this effectively

	// Request sends a request on a topic and waits for a response.
	// This is typically for server-to-server or server-to-generic-handler communication.
	Request(ctx context.Context, req *model.Message, timeoutMs int64) (*model.Message, error)

	// RequestToClient sends a request message directly to a specific client identified by brokerClientID
	// and waits for a response. The req.Header.Topic should be the "action name" the client is listening to.
	RequestToClient(ctx context.Context, brokerClientID string, req *model.Message, timeoutMs int64) (*model.Message, error)

	// RegisterConnection informs the broker about a new client connection.
	// The broker will use the ConnectionWriter to send messages to this client.
	RegisterConnection(conn ConnectionWriter) error

	// DeregisterConnection informs the broker that a client connection has closed.
	DeregisterConnection(brokerClientID string) error

	// Close shuts down the broker and cleans up resources.
	Close() error
}

// Options configures the behavior of the message broker.
type Options struct {
	QueueLength int
	// DefaultRequestTimeout is used if a request's TTL is not set or is zero.
	DefaultRequestTimeout time.Duration
}

// DefaultOptions returns default broker options.
func DefaultOptions() Options {
	return Options{
		QueueLength:           256,
		DefaultRequestTimeout: 10 * time.Second,
	}
}
```

**File: pkg/server/connection.go** (New file to adapt `nhooyr.io/websocket.Conn` to `broker.ConnectionWriter`)
```go
// pkg/server/connection.go
package server

import (
	"context"
	"encoding/json"
	"fmt"
	"sync"
	"time"

	"github.com/lightforgemedia/go-websocketmq/pkg/broker"
	"github.com/lightforgemedia/go-websocketmq/pkg/model"
	"nhooyr.io/websocket"
)

// wsConnectionAdapter adapts a *websocket.Conn to the broker.ConnectionWriter interface.
type wsConnectionAdapter struct {
	conn           *websocket.Conn
	brokerClientID string
	writeTimeout   time.Duration
	logger         broker.Logger
	mu             sync.Mutex // Protects writes to the websocket connection
}

// newWSConnectionAdapter creates a new adapter.
func newWSConnectionAdapter(conn *websocket.Conn, clientID string, writeTimeout time.Duration, logger broker.Logger) *wsConnectionAdapter {
	return &wsConnectionAdapter{
		conn:           conn,
		brokerClientID: clientID,
		writeTimeout:   writeTimeout,
		logger:         logger,
	}
}

// WriteMessage sends a message to the WebSocket client.
func (a *wsConnectionAdapter) WriteMessage(ctx context.Context, msg *model.Message) error {
	a.mu.Lock()
	defer a.mu.Unlock()

	data, err := json.Marshal(msg)
	if err != nil {
		a.logger.Error("wsConnectionAdapter: Failed to marshal message for client %s: %v", a.brokerClientID, err)
		return fmt.Errorf("failed to marshal message: %w", err)
	}

	writeCtx, cancel := context.WithTimeout(ctx, a.writeTimeout)
	defer cancel()

	if err := a.conn.Write(writeCtx, websocket.MessageText, data); err != nil {
		// Check if the error is due to context cancellation (e.g. client disconnected)
		// or a genuine write error.
		if errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) || websocket.CloseStatus(err) != -1 {
			a.logger.Warn("wsConnectionAdapter: Write to client %s failed (likely disconnected or timeout): %v", a.brokerClientID, err)
			return broker.ErrConnectionWrite // Indicate a connection issue
		}
		a.logger.Error("wsConnectionAdapter: Failed to write message to client %s: %v", a.brokerClientID, err)
		return fmt.Errorf("failed to write message: %w", err)
	}
	a.logger.Debug("wsConnectionAdapter: Sent message to client %s, topic %s, type %s", a.brokerClientID, msg.Header.Topic, msg.Header.Type)
	return nil
}

// BrokerClientID returns the unique ID for this connection.
func (a *wsConnectionAdapter) BrokerClientID() string {
	return a.brokerClientID
}

// Close closes the underlying WebSocket connection.
func (a *wsConnectionAdapter) Close() error {
	a.logger.Debug("wsConnectionAdapter: Closing connection for client %s", a.brokerClientID)
	return a.conn.Close(websocket.StatusNormalClosure, "connection closed by adapter")
}
```

**File: pkg/server/handler.go**
```go
// pkg/server/handler.go
package server

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"sync"
	"time"

	"github.com/lightforgemedia/go-websocketmq/pkg/broker"
	"github.com/lightforgemedia/go-websocketmq/pkg/model"
	"nhooyr.io/websocket"
)

// HandlerOptions configures the behavior of the WebSocket handler.
type HandlerOptions struct {
	MaxMessageSize int64
	AllowedOrigins []string
	WriteTimeout   time.Duration
	ReadTimeout    time.Duration // Note: nhooyr.io/websocket handles read timeouts differently; this is more for the write adapter.
	PingInterval   time.Duration // Note: nhooyr.io/websocket has its own keepalive. This can be for application-level pings if needed.
	// ClientRegisterTopic is the topic clients send messages to for session registration.
	ClientRegisterTopic string
}

// DefaultHandlerOptions returns default configuration.
func DefaultHandlerOptions() HandlerOptions {
	return HandlerOptions{
		MaxMessageSize:      1024 * 1024, // 1MB
		AllowedOrigins:      nil,
		WriteTimeout:        10 * time.Second,
		ReadTimeout:         60 * time.Second, // Used for initial read, then library manages
		PingInterval:        30 * time.Second,
		ClientRegisterTopic: "_client.register", // Default topic for client registration
	}
}

// Handler implements http.Handler for WebSocket connections.
type Handler struct {
	broker broker.Broker
	logger broker.Logger
	opts   HandlerOptions
	// activeBrokerClientIDs is used to prevent duplicate registration if a client sends multiple register messages
	// This is a simple mechanism; a more robust one might involve a per-connection state.
	activeBrokerClientIDs sync.Map 
}

// NewHandler creates a new WebSocket handler.
func NewHandler(b broker.Broker, logger broker.Logger, opts HandlerOptions) *Handler {
	if logger == nil {
		panic("logger must not be nil")
	}
	if b == nil {
		panic("broker must not be nil")
	}
	return &Handler{
		broker: b,
		logger: logger,
		opts:   opts,
	}
}

// ServeHTTP handles WebSocket upgrade and connection lifecycle.
func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	acceptOptions := &websocket.AcceptOptions{
		OriginPatterns: h.opts.AllowedOrigins,
		// Subprotocols:     []string{"wsmq"}, // Optional: if you define a subprotocol
	}

	conn, err := websocket.Accept(w, r, acceptOptions)
	if err != nil {
		h.logger.Error("Failed to accept WebSocket connection: %v", err)
		return
	}
	defer conn.Close(websocket.StatusInternalError, "internal server error during handler lifecycle")

	if h.opts.MaxMessageSize > 0 {
		conn.SetReadLimit(h.opts.MaxMessageSize)
	}

	// Generate a unique ID for this server-side representation of the client connection
	brokerClientID := fmt.Sprintf("wsconn-%s", model.Message{}.Header.MessageID) // Leverage existing randomID via empty message
	
	h.logger.Info("WebSocket client connected: %s, assigned BrokerClientID: %s", r.RemoteAddr, brokerClientID)

	connAdapter := newWSConnectionAdapter(conn, brokerClientID, h.opts.WriteTimeout, h.logger)

	if err := h.broker.RegisterConnection(connAdapter); err != nil {
		h.logger.Error("Failed to register connection with broker for BrokerClientID %s: %v", brokerClientID, err)
		conn.Close(websocket.StatusInternalError, "failed to register connection")
		return
	}
	h.activeBrokerClientIDs.Store(brokerClientID, true) // Mark as active

	defer func() {
		if err := h.broker.DeregisterConnection(brokerClientID); err != nil {
			h.logger.Error("Error deregistering BrokerClientID %s: %v", brokerClientID, err)
		}
		h.activeBrokerClientIDs.Delete(brokerClientID)
		h.logger.Info("WebSocket client disconnected: %s, BrokerClientID: %s", r.RemoteAddr, brokerClientID)
	}()

	ctx := r.Context() // Use request context for connection lifetime
	h.handleMessages(ctx, conn, brokerClientID)
}

// handleMessages reads and processes messages from a single WebSocket connection.
func (h *Handler) handleMessages(ctx context.Context, conn *websocket.Conn, brokerClientID string) {
	for {
		msgType, data, err := conn.Read(ctx)
		if err != nil {
			if websocket.CloseStatus(err) == websocket.StatusNormalClosure ||
				websocket.CloseStatus(err) == websocket.StatusGoingAway ||
				errors.Is(err, context.Canceled) {
				h.logger.Debug("WebSocket connection %s closed normally or context canceled: %v", brokerClientID, err)
			} else {
				h.logger.Warn("WebSocket connection %s read error: %v", brokerClientID, err)
			}
			return // Exit loop on read error or closure
		}

		if msgType != websocket.MessageText {
			h.logger.Warn("Received non-text message from client %s, ignoring", brokerClientID)
			continue
		}

		var msg model.Message
		if err := json.Unmarshal(data, &msg); err != nil {
			h.logger.Error("Failed to unmarshal message from client %s: %v. Data: %s", brokerClientID, err, string(data))
			// Optionally send an error back to the client if the message was a request
			// For now, just log and continue.
			continue
		}

		// Enrich message with source BrokerClientID for broker handlers
		msg.Header.SourceBrokerClientID = brokerClientID
		h.logger.Debug("Received message from client %s: Type=%s, Topic=%s, CorrID=%s",
			brokerClientID, msg.Header.Type, msg.Header.Topic, msg.Header.CorrelationID)

		// Handle different message types
		switch msg.Header.Type {
		case "event":
			// Publish event to the broker
			if err := h.broker.Publish(ctx, &msg); err != nil {
				h.logger.Error("Failed to publish event from client %s: %v", brokerClientID, err)
			}
		case "request":
			// This is a client-initiated request to a server-side handler.
			// The server-side handler is subscribed via broker.Subscribe().
			// The response from that handler will be sent back via its return value.
			go func(requestMsg model.Message) {
				// The topic of the request message is what the server-side handler is subscribed to.
				// The broker's Subscribe mechanism will route this.
				// We expect the broker's subscribed handler to potentially return a response.
				// The broker itself doesn't directly "respond" here; its subscribed handler does.
				// The PubSubBroker's Subscribe method already handles calling the handler
				// and publishing its response if one is returned.
				// So, we just publish it as if it's an event, but its "request" type
				// and CorrelationID signal its intent.
				// The actual request-response matching for client-to-server requests happens
				// if a server-side handler is subscribed to `requestMsg.Header.Topic`
				// and returns a response message. That response message will then be published
				// by the broker to `requestMsg.Header.CorrelationID`, which the client is listening on.

				// We simply publish this request to the broker.
				// If a handler is subscribed to msg.Header.Topic, it will process it.
				// If that handler returns a response, the PubSubBroker's Subscribe logic
				// will publish that response to msg.Header.CorrelationID.
				// The client JS library is responsible for listening on that CorrelationID.
				if err := h.broker.Publish(ctx, &requestMsg); err != nil {
					h.logger.Error("Failed to publish client request %s to broker: %v", brokerClientID, err)
					// Attempt to send an error response directly back if publishing fails
					errMsg := model.NewErrorMessage(&requestMsg, map[string]string{"error": "server failed to process request"})
					if connAdapter, ok := h.broker.(interface{ GetConnection(string) (broker.ConnectionWriter, bool) }); ok {
						if clientConn, found := connAdapter.GetConnection(brokerClientID); found {
							clientConn.WriteMessage(ctx, errMsg)
						}
					}
				}
			}(msg)

		case "response", "error":
			// This is a response from the client to a server-initiated request.
			// The message's Topic should be the CorrelationID of the original server request.
			// Publish it so the waiting RequestToClient call can pick it up.
			if msg.Header.CorrelationID == "" {
				h.logger.Warn("Received client %s %s message without CorrelationID: %+v", brokerClientID, msg.Header.Type, msg)
				continue
			}
			// The topic of a response message *is* its correlation ID.
			// The broker.RequestToClient is subscribed to this.
			if err := h.broker.Publish(ctx, &msg); err != nil {
				h.logger.Error("Failed to publish client %s %s to broker: %v", brokerClientID, msg.Header.Type, err)
			}

		case "subscribe", "unsubscribe":
			// For RPC, clients subscribe to "actionName" topics locally.
			// The server uses RequestToClient with msg.Topic = "actionName".
			// If general pub/sub from server to client is needed where clients
			// explicitly subscribe/unsubscribe to arbitrary topics, this logic would be needed.
			// For now, we assume RPC is primary, so these are logged but not processed server-side.
			h.logger.Info("Client %s sent '%s' message for topic '%s'. For RPC, clients subscribe locally to action names. This message type is not processed by server for RPC.",
				brokerClientID, msg.Header.Type, msg.Body)
			// If you want to support general client-driven subscriptions:
			// topicToManage, ok := msg.Body.(string)
			// if !ok { /* handle error */ }
			// if msg.Header.Type == "subscribe" {
			//    h.broker.SubscribeClientToTopic(brokerClientID, topicToManage) // Needs new broker method
			// } else {
			//    h.broker.UnsubscribeClientFromTopic(brokerClientID, topicToManage) // Needs new broker method
			// }

		default:
			// Handle client registration messages
			if msg.Header.Topic == h.opts.ClientRegisterTopic {
				bodyMap, ok := msg.Body.(map[string]interface{})
				if !ok {
					h.logger.Error("Invalid registration message body from client %s: not a map. Body: %+v", brokerClientID, msg.Body)
					continue
				}
				pageSessionID, ok := bodyMap["pageSessionID"].(string)
				if !ok || pageSessionID == "" {
					h.logger.Error("Invalid registration message from client %s: missing or empty pageSessionID. Body: %+v", brokerClientID, bodyMap)
					continue
				}

				// Publish an internal event for the SessionManager to pick up
				registrationEvent := model.NewEvent(broker.TopicClientRegistered, map[string]string{
					"pageSessionID":  pageSessionID,
					"brokerClientID": brokerClientID,
				})
				if err := h.broker.Publish(context.Background(), registrationEvent); err != nil { // Use background context for internal event
					h.logger.Error("Failed to publish client registration event for %s (page %s): %v", brokerClientID, pageSessionID, err)
				} else {
					h.logger.Info("Client %s registered with PageSessionID %s. Registration event published.", brokerClientID, pageSessionID)
				}
			} else {
				h.logger.Warn("Unknown message type '%s' from client %s. Topic: '%s'", msg.Header.Type, brokerClientID, msg.Header.Topic)
			}
		}
	}
}

// Close is not strictly needed for http.Handler, but can be useful for graceful shutdown.
// However, the primary cleanup is done via DeregisterConnection in the defer of ServeHTTP.
func (h *Handler) Close() error {
	h.logger.Info("WebSocketMQ Handler Close called. Active connections will be closed by their respective ServeHTTP goroutines.")
	// Note: Closing active connections here would be complex due to race conditions.
	// Rely on context cancellation and defer in ServeHTTP for individual connection cleanup.
	return nil
}

```

**File: pkg/broker/ps/ps.go**
```go
// pkg/broker/ps/ps.go
package ps

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/cskr/pubsub"
	"github.com/lightforgemedia/go-websocketmq/pkg/broker"
	"github.com/lightforgemedia/go-websocketmq/pkg/model"
)

// PubSubBroker implements the broker.Broker interface using cskr/pubsub
type PubSubBroker struct {
	bus    *pubsub.PubSub
	logger broker.Logger
	opts   broker.Options

	// For managing direct client connections
	connections      sync.Map // map[brokerClientID]broker.ConnectionWriter
	subscriptions    sync.Map // map[topicString]map[subID]broker.MessageHandler (server-side handlers)
	nextSubID        int64
	subIDMutex       sync.Mutex
	pendingRequests  sync.Map // map[correlationID]chan *model.Message
	closed           bool
	closedMutex      sync.Mutex
	shutdownComplete chan struct{}
}

type subscription struct {
	id      int64
	handler broker.MessageHandler
	ctx     context.Context // context for this specific subscription
	cancel  context.CancelFunc
}

// New creates a new PubSubBroker.
func New(logger broker.Logger, opts broker.Options) *PubSubBroker {
	if logger == nil {
		panic("logger must not be nil")
	}
	if opts.DefaultRequestTimeout == 0 {
		opts.DefaultRequestTimeout = 10 * time.Second
	}

	b := &PubSubBroker{
		bus:              pubsub.New(opts.QueueLength),
		logger:           logger,
		opts:             opts,
		shutdownComplete: make(chan struct{}),
	}
	logger.Info("PubSubBroker initialized")
	return b
}

func (b *PubSubBroker) isClosed() bool {
	b.closedMutex.Lock()
	defer b.closedMutex.Unlock()
	return b.closed
}

// Publish sends a message to subscribers.
func (b *PubSubBroker) Publish(ctx context.Context, msg *model.Message) error {
	if b.isClosed() {
		return broker.ErrBrokerClosed
	}
	if msg == nil {
		return broker.ErrInvalidMessage
	}

	// Marshal message to raw bytes for pubsub library
	// We need to be careful here: the pubsub library takes interface{},
	// but our handlers expect *model.Message.
	// To avoid double marshaling/unmarshaling, we can pass the *model.Message directly
	// if all subscribers are Go handlers. If we mix with raw byte subscribers (e.g. other systems),
	// then marshaling here is safer.
	// For now, assume we pass *model.Message directly.

	b.logger.Debug("Publishing message: Topic=%s, Type=%s, CorrID=%s, SrcClientID=%s",
		msg.Header.Topic, msg.Header.Type, msg.Header.CorrelationID, msg.Header.SourceBrokerClientID)

	// Dispatch to server-side handlers
	b.dispatchToHandlers(ctx, msg)

	// If this message is a response, it's typically targeted via its Topic (which is a CorrelationID)
	// and doesn't need to go to general topic subscribers or other clients unless explicitly designed.
	// However, if it's a general event, it might also need to be fanned out to connected clients
	// that are subscribed to this topic. This part is complex if clients subscribe to arbitrary topics.

	// For RPC, RequestToClient handles direct sending.
	// For general Pub/Sub to clients, clients would need to tell the server what they are subscribed to,
	// and the server (or broker) would need to manage these client-topic subscriptions.
	// This implementation currently focuses on server-side handlers and direct client RPC.

	// The cskr/pubsub library is used for internal signaling (e.g., responses to correlationIDs).
	// We are not using its Sub/Pub for general topic dispatch to handlers in this iteration,
	// instead, we manage subscriptions manually in b.subscriptions for more control over handler signatures.
	// Let's use the bus for correlation ID responses.
	if msg.Header.Type == "response" || msg.Header.Type == "error" {
		if msg.Header.CorrelationID != "" {
			// Marshal for the bus, as SubOnce expects raw data
			rawData, err := json.Marshal(msg)
			if err != nil {
				b.logger.Error("Failed to marshal response/error message for bus: %v", err)
				return fmt.Errorf("marshal response/error: %w", err)
			}
			b.bus.Pub(rawData, msg.Header.CorrelationID) // Topic is CorrelationID for responses
		}
	}


	return nil
}

func (b *PubSubBroker) dispatchToHandlers(ctx context.Context, msg *model.Message) {
	subsForTopic, ok := b.subscriptions.Load(msg.Header.Topic)
	if !ok {
		return
	}
	
	handlersMap, ok := subsForTopic.(*sync.Map) // map[subID]*subscription
	if !ok {
		b.logger.Error("internal error: subscription map for topic %s is not *sync.Map", msg.Header.Topic)
		return
	}

	handlersMap.Range(func(key, value interface{}) bool {
		sub, ok := value.(*subscription)
		if !ok {
			b.logger.Error("internal error: subscription value is not *subscription for topic %s", msg.Header.Topic)
			return true // continue iteration
		}

		// Check if subscription context is done
		select {
		case <-sub.ctx.Done():
			b.logger.Debug("Subscription context done for topic %s, subID %d. Skipping handler.", msg.Header.Topic, sub.id)
			// Optionally remove the subscription here if it's meant to be auto-cleaned on context done.
			// b.removeSubscription(msg.Header.Topic, sub.id)
			return true // continue iteration
		default:
			// continue to execute handler
		}
		
		// Execute handler in a new goroutine to prevent blocking the publish loop.
		go func(s *subscription, m *model.Message) {
			b.logger.Debug("Dispatching to handler for topic %s, subID %d", m.Header.Topic, s.id)
			responseMsg, err := s.handler(s.ctx, m, m.Header.SourceBrokerClientID) // Pass enriched SourceBrokerClientID
			if err != nil {
				b.logger.Error("Handler for topic %s (subID %d) returned error: %v", m.Header.Topic, s.id, err)
				// Optionally, if original message was a request, send an error response
				if m.Header.Type == "request" && m.Header.CorrelationID != "" {
					errMsg := model.NewErrorMessage(m, map[string]string{"error": fmt.Sprintf("handler error: %v", err)})
					if errPub := b.Publish(ctx, errMsg); errPub != nil {
						b.logger.Error("Failed to publish error message from handler error: %v", errPub)
					}
				}
				return
			}

			if responseMsg != nil {
				// Ensure the response is correctly correlated if the original was a request
				if m.Header.Type == "request" && m.Header.CorrelationID != "" {
					if responseMsg.Header.CorrelationID == "" {
						responseMsg.Header.CorrelationID = m.Header.CorrelationID
					}
					if responseMsg.Header.Topic == "" || responseMsg.Header.Topic == m.Header.Topic { // If topic is same as request or empty
						responseMsg.Header.Topic = m.Header.CorrelationID // Response topic is the correlation ID
					}
				}
				if err := b.Publish(s.ctx, responseMsg); err != nil { // Use subscription context for publishing response
					b.logger.Error("Failed to publish response from handler for topic %s (subID %d): %v", m.Header.Topic, s.id, err)
				}
			}
		}(sub, msg)
		return true // continue iteration
	})
}


// Subscribe registers a server-side handler for a topic.
func (b *PubSubBroker) Subscribe(ctx context.Context, topic string, handler broker.MessageHandler) error {
	if b.isClosed() {
		return broker.ErrBrokerClosed
	}
	if topic == "" {
		return errors.New("topic cannot be empty")
	}
	if handler == nil {
		return errors.New("handler cannot be nil")
	}

	b.subIDMutex.Lock()
	subID := b.nextSubID
	b.nextSubID++
	b.subIDMutex.Unlock()

	subCtx, subCancel := context.WithCancel(ctx) // Create a new context for this subscription
	newSub := &subscription{
		id:      subID,
		handler: handler,
		ctx:     subCtx,
		cancel:  subCancel,
	}

	actualMap, _ := b.subscriptions.LoadOrStore(topic, &sync.Map{})
	topicSubsMap := actualMap.(*sync.Map)
	topicSubsMap.Store(subID, newSub)

	b.logger.Info("Subscribed handler (ID %d) to topic: %s", subID, topic)

	// Goroutine to clean up subscription when its context is done
	go func() {
		<-subCtx.Done()
		b.removeSubscription(topic, subID)
		b.logger.Info("Subscription (ID %d) for topic %s cleaned up due to context cancellation.", subID, topic)
	}()

	return nil
}

func (b *PubSubBroker) removeSubscription(topic string, subID int64) {
	subsForTopic, ok := b.subscriptions.Load(topic)
	if !ok {
		return
	}
	topicSubsMap := subsForTopic.(*sync.Map)
	subValue, loaded := topicSubsMap.LoadAndDelete(subID)
	if loaded {
		if sub, ok := subValue.(*subscription); ok {
			sub.cancel() // Ensure cancel is called if not already
		}
		// If map becomes empty, consider removing it from b.subscriptions
		// This requires careful synchronization if other goroutines are adding to it.
		// For simplicity, we might leave empty maps.
	}
}


// Request sends a request and waits for a response (server-to-server or server-to-handler).
func (b *PubSubBroker) Request(ctx context.Context, req *model.Message, timeoutMs int64) (*model.Message, error) {
	if b.isClosed() {
		return nil, broker.ErrBrokerClosed
	}
	if req == nil || req.Header.CorrelationID == "" {
		return nil, broker.ErrInvalidMessage // CorrelationID is essential
	}
	if req.Header.Type != "request" {
		req.Header.Type = "request" // Ensure it's marked as a request
	}

	timeout := time.Duration(timeoutMs) * time.Millisecond
	if timeout <= 0 {
		timeout = b.opts.DefaultRequestTimeout
	}

	// Use cskr/pubsub's SubOnce for request-response on CorrelationID
	replyCh := b.bus.SubOnce(req.Header.CorrelationID)
	defer b.bus.Unsub(replyCh, req.Header.CorrelationID) // Ensure unsubscription

	if err := b.Publish(ctx, req); err != nil { // Publish will dispatch to handlers
		return nil, fmt.Errorf("failed to publish request: %w", err)
	}
	b.logger.Debug("Request published, waiting for response on CorrID: %s, Topic: %s", req.Header.CorrelationID, req.Header.Topic)

	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case <-time.After(timeout):
		return nil, broker.ErrRequestTimeout
	case rawData, ok := <-replyCh:
		if !ok {
			return nil, errors.New("reply channel closed unexpectedly")
		}
		dataBytes, ok := rawData.([]byte)
		if !ok {
			return nil, errors.New("received non-byte data on reply channel")
		}
		var resp model.Message
		if err := json.Unmarshal(dataBytes, &resp); err != nil {
			return nil, fmt.Errorf("failed to unmarshal response: %w", err)
		}
		b.logger.Debug("Response received for CorrID: %s", req.Header.CorrelationID)
		return &resp, nil
	}
}

// RequestToClient sends a request to a specific client and waits for a response.
func (b *PubSubBroker) RequestToClient(ctx context.Context, brokerClientID string, req *model.Message, timeoutMs int64) (*model.Message, error) {
	if b.isClosed() {
		return nil, broker.ErrBrokerClosed
	}
	if req == nil {
		return nil, broker.ErrInvalidMessage
	}
	if req.Header.Type != "request" {
		req.Header.Type = "request" // Ensure it's a request
	}
	if req.Header.CorrelationID == "" {
		req.Header.CorrelationID = model.Message{}.Header.MessageID // Generate new if empty
	}


	connVal, ok := b.connections.Load(brokerClientID)
	if !ok {
		b.logger.Warn("RequestToClient: Client %s not found", brokerClientID)
		return nil, broker.ErrClientNotFound
	}
	conn, ok := connVal.(broker.ConnectionWriter)
	if !ok {
		b.logger.Error("RequestToClient: Connection for client %s is of wrong type", brokerClientID)
		return nil, broker.ErrClientNotFound // Or a different internal error
	}

	timeout := time.Duration(timeoutMs) * time.Millisecond
	if timeout <= 0 {
		timeout = b.opts.DefaultRequestTimeout
	}

	replyCh := b.bus.SubOnce(req.Header.CorrelationID)
	defer b.bus.Unsub(replyCh, req.Header.CorrelationID)

	b.logger.Debug("RequestToClient: Sending to %s, Topic: %s, CorrID: %s", brokerClientID, req.Header.Topic, req.Header.CorrelationID)
	if err := conn.WriteMessage(ctx, req); err != nil {
		b.logger.Error("RequestToClient: Failed to write message to client %s: %v", brokerClientID, err)
		if errors.Is(err, broker.ErrConnectionWrite) { // If adapter signaled connection issue
			b.DeregisterConnection(brokerClientID) // Proactively deregister
		}
		return nil, broker.ErrConnectionWrite
	}

	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case <-time.After(timeout):
		b.logger.Warn("RequestToClient: Timeout waiting for response from %s on CorrID %s", brokerClientID, req.Header.CorrelationID)
		return nil, broker.ErrRequestTimeout
	case rawData, ok := <-replyCh:
		if !ok {
			b.logger.Error("RequestToClient: Reply channel for %s (CorrID %s) closed unexpectedly", brokerClientID, req.Header.CorrelationID)
			return nil, errors.New("reply channel closed")
		}
		dataBytes, ok := rawData.([]byte)
		if !ok {
			return nil, errors.New("received non-byte data on reply channel for client request")
		}
		var resp model.Message
		if err := json.Unmarshal(dataBytes, &resp); err != nil {
			b.logger.Error("RequestToClient: Failed to unmarshal response from %s (CorrID %s): %v", brokerClientID, req.Header.CorrelationID, err)
			return nil, fmt.Errorf("failed to unmarshal response: %w", err)
		}
		b.logger.Debug("RequestToClient: Response received from %s for CorrID %s", brokerClientID, req.Header.CorrelationID)
		return &resp, nil
	}
}

// RegisterConnection stores a new client connection.
func (b *PubSubBroker) RegisterConnection(conn broker.ConnectionWriter) error {
	if b.isClosed() {
		return broker.ErrBrokerClosed
	}
	if conn == nil || conn.BrokerClientID() == "" {
		return errors.New("invalid connection or empty BrokerClientID")
	}
	b.connections.Store(conn.BrokerClientID(), conn)
	b.logger.Info("Connection registered: BrokerClientID %s", conn.BrokerClientID())
	return nil
}

// DeregisterConnection removes a client connection.
func (b *PubSubBroker) DeregisterConnection(brokerClientID string) error {
	if brokerClientID == "" {
		return errors.New("BrokerClientID cannot be empty")
	}
	connVal, loaded := b.connections.LoadAndDelete(brokerClientID)
	if loaded {
		b.logger.Info("Connection deregistered: BrokerClientID %s", brokerClientID)
		// Publish an internal event that this client has disconnected
		deregisteredEvent := model.NewEvent(broker.TopicClientDeregistered, map[string]string{
			"brokerClientID": brokerClientID,
		})
		// Use a background context as this is an internal notification.
		if err := b.Publish(context.Background(), deregisteredEvent); err != nil {
			b.logger.Error("Failed to publish client deregistration event for %s: %v", brokerClientID, err)
		}
		// Optionally close the connection if it's not already closed by the server handler
		if conn, ok := connVal.(broker.ConnectionWriter); ok {
			 go conn.Close() // Close in a goroutine to avoid blocking
		}

	} else {
		b.logger.Warn("Attempted to deregister non-existent or already deregistered client: %s", brokerClientID)
	}
	return nil
}

// GetConnection (utility for server.Handler, not part of broker.Broker interface)
// This is a helper that might be used by server.Handler if it needs to send an error
// back to a client when broker.Publish fails for a client-initiated request.
// It's a bit of a layering concern, so use with caution.
func (b *PubSubBroker) GetConnection(brokerClientID string) (broker.ConnectionWriter, bool) {
	connVal, ok := b.connections.Load(brokerClientID)
	if !ok {
		return nil, false
	}
	conn, ok := connVal.(broker.ConnectionWriter)
	return conn, ok
}


// Close shuts down the broker.
func (b *PubSubBroker) Close() error {
	b.closedMutex.Lock()
	if b.closed {
		b.closedMutex.Unlock()
		return broker.ErrBrokerClosed
	}
	b.closed = true
	b.closedMutex.Unlock()

	b.logger.Info("PubSubBroker closing...")

	// Close all client connections
	b.connections.Range(func(key, value interface{}) bool {
		brokerClientID := key.(string)
		conn := value.(broker.ConnectionWriter)
		b.logger.Debug("Closing connection for client %s during broker shutdown", brokerClientID)
		conn.Close() // This should ideally trigger DeregisterConnection flow too
		b.connections.Delete(brokerClientID) // Ensure removal
		return true
	})
	b.logger.Info("All client connections instructed to close.")
	
	// Cancel all server-side subscriptions
	b.subscriptions.Range(func(topicKey, topicValue interface{}) bool {
		topicSubsMap, ok := topicValue.(*sync.Map)
		if !ok { return true }
		topicSubsMap.Range(func(subKey, subValue interface{}) bool {
			if sub, ok := subValue.(*subscription); ok {
				sub.cancel() // This will trigger cleanup goroutine for each subscription
			}
			return true
		})
		return true
	})
	b.logger.Info("All server-side subscriptions cancelled.")

	// Shutdown the cskr/pubsub bus
	// The library doesn't have an explicit Close/Shutdown. We rely on Unsub.
	// Outstanding SubOnce calls will eventually timeout or their channels will close.

	// Wait for a brief period for goroutines to finish
	// This is a heuristic. A more robust way would involve wait groups for active handlers.
	time.Sleep(100 * time.Millisecond) 

	close(b.shutdownComplete) // Signal that shutdown is complete
	b.logger.Info("PubSubBroker closed.")
	return nil
}

// Wait for shutdown to complete (for testing or graceful shutdown)
func (b *PubSubBroker) WaitForShutdown() {
	<-b.shutdownComplete
}
```

**File: assets/dist/websocketmq.js** (Client JS - with registration)
```javascript
// assets/dist/websocketmq.js
// WebSocketMQ Client v2 (RPC Enhancements)

window.WebSocketMQ = window.WebSocketMQ || {};

WebSocketMQ.Client = class {
  constructor(options = {}) {
    this.options = Object.assign({
      url: null,
      reconnect: true,
      reconnectInterval: 1000,
      maxReconnectInterval: 30000,
      reconnectMultiplier: 1.5,
      devMode: false,
      logger: console, // Allow custom logger
      // New option for registration
      pageSessionID: null, // User-defined session ID for this client instance
      clientRegisterTopic: "_client.register", // Topic to publish registration
    }, options);

    if (!this.options.url) {
      throw new Error('WebSocketMQ: URL is required');
    }
    this.logger = this.options.logger;

    this.ws = null;
    this.isConnected = false;
    this.isConnecting = false;
    this.reconnectAttempts = 0;
    this.reconnectTimer = null;
    this.explicitlyClosed = false;
    
    this.subscriptions = new Map(); // topic -> Set of handlers
    this.onConnectCallbacks = new Set();
    this.onDisconnectCallbacks = new Set();
    this.onErrorCallbacks = new Set();
    
    this._onMessage = this._onMessage.bind(this);
    this._onOpen = this._onOpen.bind(this);
    this._onClose = this._onClose.bind(this);
    this._onError = this._onError.bind(this);
    
    if (this.options.devMode) {
      this._setupDevMode();
    }
  }
  
  connect() {
    if (this.isConnected || this.isConnecting) {
      this.logger.debug('WebSocketMQ: Already connected or connecting.');
      return;
    }
    
    this.isConnecting = true;
    this.explicitlyClosed = false;
    this.logger.debug('WebSocketMQ: Connecting to', this.options.url);
    
    try {
      this.ws = new WebSocket(this.options.url);
      this.ws.addEventListener('open', this._onOpen);
      this.ws.addEventListener('message', this._onMessage);
      this.ws.addEventListener('close', this._onClose);
      this.ws.addEventListener('error', this._onError);
    } catch (err) {
      this.isConnecting = false;
      this._handleError(err);
      if (!this.explicitlyClosed) this._scheduleReconnect();
    }
  }
  
  disconnect() {
    this.logger.debug('WebSocketMQ: Disconnect called.');
    this.explicitlyClosed = true;
    clearTimeout(this.reconnectTimer);
    this.reconnectTimer = null;
    
    if (this.ws) {
      try {
        this.ws.close(1000, 'Client disconnected');
      } catch (err) { /* Ignore */ }
    }
    // _onClose will handle state changes and callbacks
  }
  
  _registerClientSession() {
    if (this.options.pageSessionID && this.options.clientRegisterTopic) {
      this.logger.info(`WebSocketMQ: Registering PageSessionID: ${this.options.pageSessionID}`);
      try {
        this.publish(this.options.clientRegisterTopic, { pageSessionID: this.options.pageSessionID });
      } catch (err) {
        this.logger.error('WebSocketMQ: Failed to send registration message:', err);
      }
    }
  }

  publish(topic, body) {
    if (!this.isConnected) {
      this.logger.warn('WebSocketMQ: Not connected. Cannot publish.');
      throw new Error('WebSocketMQ: Not connected');
    }
    
    const message = {
      header: {
        messageID: this._generateID(),
        type: 'event',
        topic: topic,
        timestamp: Date.now()
      },
      body: body
    };
    this._sendMessage(message);
    this.logger.debug('WebSocketMQ: Published to', topic, body);
    return true;
  }
  
  // Subscribe to an action name (for server-initiated RPC) or a general topic
  subscribe(topic, handler) {
    if (!handler || typeof handler !== 'function') {
      throw new Error('WebSocketMQ: Handler must be a function');
    }
    
    if (!this.subscriptions.has(topic)) {
      this.subscriptions.set(topic, new Set());
    }
    this.subscriptions.get(topic).add(handler);
    this.logger.debug('WebSocketMQ: Subscribed to topic:', topic);

    // For general pub/sub (not RPC action names), client might need to inform server.
    // For RPC action names, server initiates, so client doesn't need to send "subscribe" message.
    // We are simplifying: client manages its subscriptions locally for RPC.
    // If general pub/sub from server to client groups is needed, client would send a "subscribe" type message.

    return () => {
      if (this.subscriptions.has(topic)) {
        const handlers = this.subscriptions.get(topic);
        handlers.delete(handler);
        if (handlers.size === 0) {
          this.subscriptions.delete(topic);
          this.logger.debug('WebSocketMQ: Unsubscribed from topic (last handler removed):', topic);
          // Optionally send "unsubscribe" message to server if it was for general pub/sub
        }
      }
    };
  }
  
  // Client-initiated request to a server-side handler
  request(topic, body, timeoutMs = 5000) {
    if (!this.isConnected) {
      this.logger.warn('WebSocketMQ: Not connected. Cannot send request.');
      return Promise.reject(new Error('WebSocketMQ: Not connected'));
    }
    
    return new Promise((resolve, reject) => {
      const correlationID = this._generateID();
      let timeoutId = null;

      const responseHandler = (responseBody, responseMessage) => {
        clearTimeout(timeoutId);
        // Clean up this specific one-time subscription
        if (this.subscriptions.has(correlationID)) {
            const handlers = this.subscriptions.get(correlationID);
            handlers.delete(responseHandler);
            if (handlers.size === 0) this.subscriptions.delete(correlationID);
        }

        if (responseMessage.header.type === 'error') {
          this.logger.warn('WebSocketMQ: Request to', topic, 'failed with error:', responseBody);
          reject(responseBody.error ? new Error(responseBody.error.message || responseBody.error) : new Error('Request failed'));
        } else {
          this.logger.debug('WebSocketMQ: Response for', topic, '(CorrID', correlationID, '):', responseBody);
          resolve(responseBody);
        }
      };
      
      // Subscribe to the correlationID for the response
      if (!this.subscriptions.has(correlationID)) {
        this.subscriptions.set(correlationID, new Set());
      }
      this.subscriptions.get(correlationID).add(responseHandler);
      
      timeoutId = setTimeout(() => {
        if (this.subscriptions.has(correlationID)) {
            const handlers = this.subscriptions.get(correlationID);
            handlers.delete(responseHandler);
            if (handlers.size === 0) this.subscriptions.delete(correlationID);
        }
        this.logger.warn('WebSocketMQ: Request to', topic, 'timed out for CorrID', correlationID);
        reject(new Error('WebSocketMQ: Request timed out'));
      }, timeoutMs);
      
      const message = {
        header: {
          messageID: this._generateID(),
          correlationID: correlationID,
          type: 'request',
          topic: topic, // Topic the server handler is listening on
          timestamp: Date.now(),
          ttl: timeoutMs
        },
        body: body
      };
      
      this._sendMessage(message);
      this.logger.debug('WebSocketMQ: Sent request to', topic, '(CorrID', correlationID, '):', body);
    });
  }
  
  onConnect(callback) { this.onConnectCallbacks.add(callback); if (this.isConnected) callback(); }
  onDisconnect(callback) { this.onDisconnectCallbacks.add(callback); }
  onError(callback) { this.onErrorCallbacks.add(callback); }
  
  _onOpen(event) {
    this.isConnected = true;
    this.isConnecting = false;
    this.reconnectAttempts = 0;
    this.logger.info('WebSocketMQ: Connected.');
    
    this._registerClientSession(); // Attempt to register if pageSessionID is set

    this.onConnectCallbacks.forEach(cb => { try { cb(event); } catch(e) { this.logger.error("Error in onConnect callback", e)} });
  }
  
  _onClose(event) {
    const wasConnected = this.isConnected;
    this.isConnected = false;
    this.isConnecting = false;
    this.logger.info('WebSocketMQ: Disconnected. Code:', event.code, 'Reason:', event.reason, 'WasClean:', event.wasClean);
    
    if (wasConnected) { // Only call disconnect if it was previously connected
        this.onDisconnectCallbacks.forEach(cb => { try { cb(event); } catch(e) { this.logger.error("Error in onDisconnect callback", e)} });
    }
    
    if (!this.explicitlyClosed && this.options.reconnect) {
      this._scheduleReconnect();
    }
  }
  
  _onError(eventOrError) {
    // WebSocket 'error' events are simple events, not Error objects.
    // Actual Error objects might come from other parts of the code.
    const error = eventOrError instanceof Error ? eventOrError : new Error('WebSocket error');
    this.logger.error('WebSocketMQ: Error:', error, 'Raw event:', eventOrError);
    this.onErrorCallbacks.forEach(cb => { try { cb(error, eventOrError); } catch(e) { this.logger.error("Error in onError callback", e)} });
    // Note: A WebSocket 'error' event is typically followed by a 'close' event.
    // Reconnection logic is handled in _onClose.
  }
  
  _onMessage(event) {
    let message;
    try {
      message = JSON.parse(event.data);
      this.logger.debug('WebSocketMQ: Received message:', message);
    } catch (err) {
      this._handleError(new Error(`WebSocketMQ: Failed to parse message: ${err.message}. Data: ${event.data}`));
      return;
    }

    const topic = message.header.topic; // For events, requests, or responses (where topic=correlationID)
    const handlers = this.subscriptions.get(topic);

    if (handlers && handlers.size > 0) {
      handlers.forEach(async (handler) => {
        try {
          if (message.header.type === 'request') {
            this.logger.debug('WebSocketMQ: Handling server-initiated request for action:', topic);
            const result = await handler(message.body, message); // Handler for server-initiated RPC
            
            if (result !== undefined && message.header.correlationID) { // Check undefined explicitly
              const response = {
                header: {
                  messageID: this._generateID(),
                  correlationID: message.header.correlationID,
                  type: 'response',
                  topic: message.header.correlationID, // Response topic is the original request's CorrID
                  timestamp: Date.now()
                },
                body: result
              };
              this._sendMessage(response);
              this.logger.debug('WebSocketMQ: Sent response for server-initiated request on action', topic, 'Result:', result);
            }
          } else {
            // Handler for general events or client-initiated request responses
             handler(message.body, message);
          }
        } catch (err) {
          this.logger.error(`WebSocketMQ: Error in message handler for topic ${topic}:`, err);
          if (message.header.type === 'request' && message.header.correlationID) {
            const errorResponse = {
              header: {
                messageID: this._generateID(),
                correlationID: message.header.correlationID,
                type: 'error',
                topic: message.header.correlationID,
                timestamp: Date.now()
              },
              body: { error: { message: err.message || 'Handler error' } }
            };
            this._sendMessage(errorResponse);
          }
        }
      });
    } else {
        this.logger.debug('WebSocketMQ: No handlers for topic:', topic, 'Message type:', message.header.type);
    }
  }
  
  _sendMessage(message) {
    if (!this.isConnected || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
      this.logger.warn('WebSocketMQ: Not connected or WebSocket not open. Cannot send message.');
      // Do not throw here, as it might be a normal race condition during disconnect.
      return false;
    }
    try {
      this.ws.send(JSON.stringify(message));
      return true;
    } catch (err) {
      this._handleError(err); // This will call onError callbacks
      return false;
    }
  }
  
  _handleError(error) {
    this.logger.error('WebSocketMQ: Handling error:', error);
    this.onErrorCallbacks.forEach(cb => { try { cb(error); } catch(e) { this.logger.error("Error in _handleError's onError callback", e)} });
  }
  
  _scheduleReconnect() {
    if (this.explicitlyClosed || !this.options.reconnect || this.reconnectTimer) {
      return;
    }
    
    this.reconnectAttempts++;
    const interval = Math.min(
      this.options.reconnectInterval * Math.pow(this.options.reconnectMultiplier, this.reconnectAttempts -1),
      this.options.maxReconnectInterval
    );
    
    this.logger.info(`WebSocketMQ: Scheduling reconnect attempt ${this.reconnectAttempts} in ${interval}ms.`);
    this.reconnectTimer = setTimeout(() => {
      this.reconnectTimer = null;
      if (!this.explicitlyClosed) this.connect();
    }, interval);
  }
  
  _generateID() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2, 10);
  }
  
  _setupDevMode() {
    this.onConnect(() => {
      this.subscribe('_dev.hotreload', () => {
        this.logger.info('WebSocketMQ: Hot reload triggered, refreshing page...');
        window.location.reload();
      });
      this.logger.info('WebSocketMQ: Development mode active - JS error reporting enabled.');
    });
    
    const reportError = (errorData) => {
      if (!this.isConnected) {
        this.logger.warn('WebSocketMQ: Cannot report JS error - not connected', errorData);
        return;
      }
      this.logger.debug('WebSocketMQ: Reporting JS error to server:', errorData);
      try {
        this.publish('_dev.js-error', errorData);
      } catch (err) {
        this.logger.error('WebSocketMQ: Failed to report JS error to server:', err);
      }
    };

    window.addEventListener('error', (event) => {
      reportError({
        message: event.message,
        source: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error ? event.error.stack : null,
        timestamp: new Date().toISOString(),
        type: "window.onerror"
      });
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      reportError({
        message: event.reason ? (event.reason.message || String(event.reason)) : 'Unhandled Promise Rejection',
        stack: event.reason && event.reason.stack ? event.reason.stack : null,
        timestamp: new Date().toISOString(),
        type: "unhandledrejection"
      });
    });
  }
};
```

This is a significant chunk. Next, I'll provide the minified JS, `websocketmq.go` facade, and then move to the example project. The tests for these modified broker/server components would also need substantial updates, which I'll omit for brevity in this generation pass but are critical in a real project.

**File: assets/dist/websocketmq.min.js**
```javascript
// assets/dist/websocketmq.min.js
window.WebSocketMQ=window.WebSocketMQ||{},WebSocketMQ.Client=class{constructor(e={}){if(this.options=Object.assign({url:null,reconnect:!0,reconnectInterval:1e3,maxReconnectInterval:3e4,reconnectMultiplier:1.5,devMode:!1,logger:console,pageSessionID:null,clientRegisterTopic:"_client.register"},e),!this.options.url)throw new Error("WebSocketMQ: URL is required");this.logger=this.options.logger,this.ws=null,this.isConnected=!1,this.isConnecting=!1,this.reconnectAttempts=0,this.reconnectTimer=null,this.explicitlyClosed=!1,this.subscriptions=new Map,this.onConnectCallbacks=new Set,this.onDisconnectCallbacks=new Set,this.onErrorCallbacks=new Set,this._onMessage=this._onMessage.bind(this),this._onOpen=this._onOpen.bind(this),this._onClose=this._onClose.bind(this),this._onError=this._onError.bind(this),this.options.devMode&&this._setupDevMode()}connect(){this.isConnected||this.isConnecting?(this.logger.debug("WebSocketMQ: Already connected or connecting."),void 0):(this.isConnecting=!0,this.explicitlyClosed=!1,this.logger.debug("WebSocketMQ: Connecting to",this.options.url),void 0);try{this.ws=new WebSocket(this.options.url),this.ws.addEventListener("open",this._onOpen),this.ws.addEventListener("message",this._onMessage),this.ws.addEventListener("close",this._onClose),this.ws.addEventListener("error",this._onError)}catch(e){this.isConnecting=!1,this._handleError(e),this.explicitlyClosed||this._scheduleReconnect()}}disconnect(){this.logger.debug("WebSocketMQ: Disconnect called."),this.explicitlyClosed=!0,clearTimeout(this.reconnectTimer),this.reconnectTimer=null,this.ws&&void 0;try{this.ws.close(1e3,"Client disconnected")}catch{}}_registerClientSession(){if(this.options.pageSessionID&&this.options.clientRegisterTopic){this.logger.info(`WebSocketMQ: Registering PageSessionID: ${this.options.pageSessionID}`);try{this.publish(this.options.clientRegisterTopic,{pageSessionID:this.options.pageSessionID})}catch(e){this.logger.error("WebSocketMQ: Failed to send registration message:",e)}}}publish(e,t){if(!this.isConnected)throw this.logger.warn("WebSocketMQ: Not connected. Cannot publish."),new Error("WebSocketMQ: Not connected");const s={header:{messageID:this._generateID(),type:"event",topic:e,timestamp:Date.now()},body:t};this._sendMessage(s),this.logger.debug("WebSocketMQ: Published to",e,t);return!0}subscribe(e,t){if(!t||"function"!=typeof t)throw new Error("WebSocketMQ: Handler must be a function");this.subscriptions.has(e)||this.subscriptions.set(e,new Set),this.subscriptions.get(e).add(t),this.logger.debug("WebSocketMQ: Subscribed to topic:",e);return()=>{if(this.subscriptions.has(e)){const s=this.subscriptions.get(e);s.delete(t),0===s.size&&(this.subscriptions.delete(e),this.logger.debug("WebSocketMQ: Unsubscribed from topic (last handler removed):",e),void 0)}}}request(e,t,s=5e3){return this.isConnected?new Promise((i,o)=>{const n=this._generateID();let r=null;const a=(t,s)=>{clearTimeout(r),this.subscriptions.has(n)&&void 0;const c=this.subscriptions.get(n);c.delete(a),0===c.size&&this.subscriptions.delete(n),"error"===s.header.type?(this.logger.warn("WebSocketMQ: Request to",e,"failed with error:",t),o(t.error?new Error(t.error.message||t.error):new Error("Request failed"))):(this.logger.debug("WebSocketMQ: Response for",e,"(CorrID",n,"):",t),i(t))};this.subscriptions.has(n)||this.subscriptions.set(n,new Set),this.subscriptions.get(n).add(a),r=setTimeout(()=>{this.subscriptions.has(n)&&void 0;const t=this.subscriptions.get(n);t.delete(a),0===t.size&&this.subscriptions.delete(n),this.logger.warn("WebSocketMQ: Request to",e,"timed out for CorrID",n),o(new Error("WebSocketMQ: Request timed out"))},s);const c={header:{messageID:this._generateID(),correlationID:n,type:"request",topic:e,timestamp:Date.now(),ttl:s},body:t};this._sendMessage(c),this.logger.debug("WebSocketMQ: Sent request to",e,"(CorrID",n,"):",t)}):(this.logger.warn("WebSocketMQ: Not connected. Cannot send request."),Promise.reject(new Error("WebSocketMQ: Not connected")))}onConnect(e){this.onConnectCallbacks.add(e),this.isConnected&&e()}onDisconnect(e){this.onDisconnectCallbacks.add(e)}onError(e){this.onErrorCallbacks.add(e)}_onOpen(e){this.isConnected=!0,this.isConnecting=!1,this.reconnectAttempts=0,this.logger.info("WebSocketMQ: Connected."),this._registerClientSession(),this.onConnectCallbacks.forEach(t=>{try{t(e)}catch(e){this.logger.error("Error in onConnect callback",e)}})}_onClose(e){const t=this.isConnected;this.isConnected=!1,this.isConnecting=!1,this.logger.info("WebSocketMQ: Disconnected. Code:",e.code,"Reason:",e.reason,"WasClean:",e.wasClean),t&&this.onDisconnectCallbacks.forEach(t=>{try{t(e)}catch(e){this.logger.error("Error in onDisconnect callback",e)}}),!this.explicitlyClosed&&this.options.reconnect&&this._scheduleReconnect()}_onError(e){const t=e instanceof Error?e:new Error("WebSocket error");this.logger.error("WebSocketMQ: Error:",t,"Raw event:",e),this.onErrorCallbacks.forEach(s=>{try{s(t,e)}catch(e){this.logger.error("Error in onError callback",e)}})}_onMessage(e){let t;try{t=JSON.parse(e.data),this.logger.debug("WebSocketMQ: Received message:",t)}catch(s){return this._handleError(new Error(`WebSocketMQ: Failed to parse message: ${s.message}. Data: ${e.data}`)),void 0}const s=t.header.topic,i=this.subscriptions.get(s);i&&i.size>0?i.forEach(async e=>{try{"request"===t.header.type?(this.logger.debug("WebSocketMQ: Handling server-initiated request for action:",s),void 0):e(t.body,t);const i=await e(t.body,t);void 0===i||!t.header.correlationID||void 0;const o={header:{messageID:this._generateID(),correlationID:t.header.correlationID,type:"response",topic:t.header.correlationID,timestamp:Date.now()},body:i};this._sendMessage(o),this.logger.debug("WebSocketMQ: Sent response for server-initiated request on action",s,"Result:",i)}catch(e){this.logger.error(`WebSocketMQ: Error in message handler for topic ${s}:`,e),"request"===t.header.type&&t.header.correlationID&&void 0;const i={header:{messageID:this._generateID(),correlationID:t.header.correlationID,type:"error",topic:t.header.correlationID,timestamp:Date.now()},body:{error:{message:e.message||"Handler error"}}};this._sendMessage(i)}}):this.logger.debug("WebSocketMQ: No handlers for topic:",s,"Message type:",t.header.type)}_sendMessage(e){if(!this.isConnected||!this.ws||this.ws.readyState!==WebSocket.OPEN)return this.logger.warn("WebSocketMQ: Not connected or WebSocket not open. Cannot send message."),!1;try{return this.ws.send(JSON.stringify(e)),!0}catch(e){return this._handleError(e),!1}}_handleError(e){this.logger.error("WebSocketMQ: Handling error:",e),this.onErrorCallbacks.forEach(t=>{try{t(e)}catch(e){this.logger.error("Error in _handleError's onError callback",e)}})}_scheduleReconnect(){if(this.explicitlyClosed||!this.options.reconnect||this.reconnectTimer)return;this.reconnectAttempts++;const e=Math.min(this.options.reconnectInterval*Math.pow(this.options.reconnectMultiplier,this.reconnectAttempts-1),this.options.maxReconnectInterval);this.logger.info(`WebSocketMQ: Scheduling reconnect attempt ${this.reconnectAttempts} in ${e}ms.`),this.reconnectTimer=setTimeout(()=>{this.reconnectTimer=null,this.explicitlyClosed||this.connect()},e)}_generateID(){return Date.now().toString(36)+Math.random().toString(36).substring(2,10)}_setupDevMode(){this.onConnect(()=>{this.subscribe("_dev.hotreload",()=>{this.logger.info("WebSocketMQ: Hot reload triggered, refreshing page..."),window.location.reload()}),this.logger.info("WebSocketMQ: Development mode active - JS error reporting enabled.")});const e=t=>{this.isConnected?(this.logger.debug("WebSocketMQ: Reporting JS error to server:",t),void 0):this.logger.warn("WebSocketMQ: Cannot report JS error - not connected",t);try{this.publish("_dev.js-error",t)}catch(e){this.logger.error("WebSocketMQ: Failed to report JS error to server:",e)}};window.addEventListener("error",t=>{e({message:t.message,source:t.filename,lineno:t.lineno,colno:t.colno,stack:t.error?t.error.stack:null,timestamp:(new Date).toISOString(),type:"window.onerror"})}),window.addEventListener("unhandledrejection",t=>{e({message:t.reason?t.reason.message||String(t.reason):"Unhandled Promise Rejection",stack:t.reason&&t.reason.stack?t.reason.stack:null,timestamp:(new Date).toISOString(),type:"unhandledrejection"})})}}
```

**File: websocketmq.go** (Main package facade)
```go
// websocketmq.go
package websocketmq

import (
	"context"
	"net/http"
	"time"

	"github.com/lightforgemedia/go-websocketmq/assets"
	"github.com/lightforgemedia/go-websocketmq/internal/devwatch"
	"github.com/lightforgemedia/go-websocketmq/pkg/broker"
	"github.com/lightforgemedia/go-websocketmq/pkg/broker/ps"
	"github.com/lightforgemedia/go-websocketmq/pkg/model"
	"github.com/lightforgemedia/go-websocketmq/pkg/server"
)

//go:generate go run ./internal/buildjs/main.go

// Re-export core types
type (
	Message        = model.Message
	MessageHeader  = model.MessageHeader
	Broker         = broker.Broker
	Logger         = broker.Logger
	MessageHandler = broker.MessageHandler // New: Expose the server-side handler type
	ConnectionWriter = broker.ConnectionWriter // New: Expose connection writer interface
	WebSocketHandler = server.Handler // Renamed from Handler for clarity
	HandlerOptions = server.HandlerOptions
	BrokerOptions  = broker.Options
	WatchOptions   = devwatch.WatchOptions
)

// Re-export error types
var (
	ErrClientNotFound  = broker.ErrClientNotFound
	ErrRequestTimeout  = broker.ErrRequestTimeout
	ErrConnectionWrite = broker.ErrConnectionWrite
	ErrBrokerClosed    = broker.ErrBrokerClosed
	ErrInvalidMessage  = broker.ErrInvalidMessage
)

// Re-export constants for internal broker events (application might want to listen)
const (
	TopicClientRegistered   = broker.TopicClientRegistered
	TopicClientDeregistered = broker.TopicClientDeregistered
)


// NewEvent creates a new event message.
func NewEvent(topic string, body any) *model.Message {
	return model.NewEvent(topic, body)
}

// NewRequest creates a new request message.
// For server-to-client RPC, 'topic' will be the action/procedure name.
func NewRequest(topic string, body any, timeoutMs int64) *model.Message {
	return model.NewRequest(topic, body, timeoutMs)
}

// NewResponse creates a new response message for a received request.
func NewResponse(req *model.Message, body any) *model.Message {
	return model.NewResponse(req, body)
}

// NewErrorMessage creates a new error response message.
func NewErrorMessage(req *model.Message, errorBody any) *model.Message {
	return model.NewErrorMessage(req, errorBody)
}


// DefaultHandlerOptions returns default options for the WebSocket handler.
func DefaultHandlerOptions() server.HandlerOptions { // Return concrete type
	return server.DefaultHandlerOptions()
}

// DefaultBrokerOptions returns default options for the broker.
func DefaultBrokerOptions() broker.Options { // Return concrete type
	return broker.DefaultOptions()
}

// DefaultDevWatchOptions returns default options for the development watcher.
func DefaultDevWatchOptions() devwatch.WatchOptions { // Return concrete type
	return devwatch.DefaultWatchOptions()
}

// NewPubSubBroker creates a new in-memory broker.
func NewPubSubBroker(logger broker.Logger, opts broker.Options) broker.Broker { // Return interface type
	return ps.New(logger, opts)
}

// NewWebSocketHandler creates a new WebSocket connection handler.
func NewWebSocketHandler(b broker.Broker, logger broker.Logger, opts server.HandlerOptions) *server.Handler { // Return concrete type
	return server.NewHandler(b, logger, opts)
}

// ScriptHandler serves the embedded JavaScript client.
func ScriptHandler() http.Handler {
	return assets.ScriptHandler()
}

// GetClientScript returns the JavaScript client as a byte slice.
func GetClientScript(minified bool) ([]byte, error) {
	return assets.GetClientScript(minified)
}

// StartDevWatcher starts a file watcher for hot-reload events.
func StartDevWatcher(ctx context.Context, b broker.Broker, logger broker.Logger, opts devwatch.WatchOptions) (func() error, error) {
	return devwatch.StartWatcher(ctx, b, logger, opts)
}
```

**File: assets/embed.go**
```go
// assets/embed.go
package assets

import (
	"embed"
)

//go:embed dist/websocketmq.js dist/websocketmq.min.js
var clientFiles embed.FS
```

**File: assets/handler.go** (No changes needed)
```go
// assets/handler.go
package assets

import (
	"net/http"
	"path"
	"strings"
)

// ScriptHandler returns an HTTP handler that serves the embedded JavaScript client
func ScriptHandler() http.Handler {
	return &scriptHandler{}
}

type scriptHandler struct{}

func (h *scriptHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Get the requested file path
	filePath := strings.TrimPrefix(r.URL.Path, "/")
	if filePath == "" {
		filePath = "websocketmq.min.js" // Default to minified version
	}

	// Map the requested path to the embedded file path
	embeddedPath := path.Join("dist", filePath)

	data, err := clientFiles.ReadFile(embeddedPath)
	if err != nil {
		http.Error(w, "File not found", http.StatusNotFound)
		return
	}

	contentType := "application/javascript"
	if strings.HasSuffix(filePath, ".map") {
		contentType = "application/json" // Source maps if you generate them
	}

	w.Header().Set("Content-Type", contentType)
	w.Header().Set("Cache-Control", "max-age=3600") 
	
	w.Write(data)
}

func GetClientScript(minified bool) ([]byte, error) {
	var filename string
	if minified {
		filename = "dist/websocketmq.min.js"
	} else {
		filename = "dist/websocketmq.js"
	}
	return clientFiles.ReadFile(filename)
}
```

**File: internal/buildjs/main.go** (No changes needed, assuming `client/src/client.js` is the source for `assets/dist/websocketmq.js`)

**File: internal/devwatch/watcher.go** (No changes needed)

---
This completes Phase 1 of the library modifications. The core components (`model`, `broker`, `server`, `assets/js`) have been updated to support the new RPC flow with client identification and targeted requests.

Next, I will generate the example project (`cmd/rpcserver`) that utilizes these new library features.Okay, Phase 1 (Core Library Enhancements) is complete. Now, let's build the example project (`cmd/rpcserver`) that demonstrates these new capabilities.

**Phase 2: Example Project (`cmd/rpcserver`)**

First, create the directory structure for the example:
```
cmd/
└── rpcserver/
    ├── main.go
    ├── session/
    │   └── manager.go
    ├── api/
    │   └── handler.go
    └── static/
        ├── index.html
        ├── browser_automation_mock.js
        └── style.css
```

**File: cmd/rpcserver/session/manager.go**
```go
// cmd/rpcserver/session/manager.go
package session

import (
	"context"
	"sync"

	"github.com/lightforgemedia/go-websocketmq" // Import the updated library
)

// Manager handles the mapping between user-defined PageSessionIDs and internal BrokerClientIDs.
type Manager struct {
	logger websocketmq.Logger
	broker websocketmq.Broker // To subscribe to broker events

	// pageToBroker maps PageSessionID (string) to BrokerClientID (string)
	pageToBroker sync.Map
	// brokerToPage maps BrokerClientID (string) to PageSessionID (string)
	brokerToPage sync.Map
}

// NewManager creates a new session manager.
func NewManager(logger websocketmq.Logger, broker websocketmq.Broker) *Manager {
	m := &Manager{
		logger: logger,
		broker: broker,
	}
	m.startEventListeners()
	return m
}

// startEventListeners subscribes to relevant broker events for session management.
func (m *Manager) startEventListeners() {
	// Subscribe to client registration events
	err := m.broker.Subscribe(context.Background(), websocketmq.TopicClientRegistered, m.handleClientRegistered)
	if err != nil {
		m.logger.Error("SessionManager: Failed to subscribe to TopicClientRegistered: %v", err)
		// This is a critical failure for session management. Consider panic or retry.
	} else {
		m.logger.Info("SessionManager: Subscribed to TopicClientRegistered")
	}

	// Subscribe to client deregistration events
	err = m.broker.Subscribe(context.Background(), websocketmq.TopicClientDeregistered, m.handleClientDeregistered)
	if err != nil {
		m.logger.Error("SessionManager: Failed to subscribe to TopicClientDeregistered: %v", err)
	} else {
		m.logger.Info("SessionManager: Subscribed to TopicClientDeregistered")
	}
}

// handleClientRegistered processes client registration events from the broker.
func (m *Manager) handleClientRegistered(ctx context.Context, msg *websocketmq.Message, sourceBrokerClientID string) (*websocketmq.Message, error) {
	bodyMap, ok := msg.Body.(map[string]string) // Expecting map[string]string from broker event
	if !ok {
		m.logger.Error("SessionManager: Invalid body for TopicClientRegistered: not map[string]string. Body: %+v", msg.Body)
		return nil, nil // No response needed for internal event
	}

	pageSessionID, pExists := bodyMap["pageSessionID"]
	brokerClientID, bExists := bodyMap["brokerClientID"]

	if !pExists || !bExists || pageSessionID == "" || brokerClientID == "" {
		m.logger.Error("SessionManager: Malformed TopicClientRegistered event: missing pageSessionID or brokerClientID. Body: %+v", bodyMap)
		return nil, nil
	}

	// Clean up any old associations for this pageSessionID or brokerClientID
	if oldBrokerID, loaded := m.pageToBroker.Load(pageSessionID); loaded {
		m.brokerToPage.Delete(oldBrokerID.(string))
	}
	if oldPageID, loaded := m.brokerToPage.Load(brokerClientID); loaded {
		m.pageToBroker.Delete(oldPageID.(string))
	}
	
	m.pageToBroker.Store(pageSessionID, brokerClientID)
	m.brokerToPage.Store(brokerClientID, pageSessionID)
	m.logger.Info("SessionManager: Registered session. PageSessionID: %s <-> BrokerClientID: %s", pageSessionID, brokerClientID)
	return nil, nil
}

// handleClientDeregistered processes client deregistration events from the broker.
func (m *Manager) handleClientDeregistered(ctx context.Context, msg *websocketmq.Message, sourceBrokerClientID string) (*websocketmq.Message, error) {
	bodyMap, ok := msg.Body.(map[string]string)
	if !ok {
		m.logger.Error("SessionManager: Invalid body for TopicClientDeregistered: not map[string]string. Body: %+v", msg.Body)
		return nil, nil
	}

	brokerClientID, exists := bodyMap["brokerClientID"]
	if !exists || brokerClientID == "" {
		m.logger.Error("SessionManager: Malformed TopicClientDeregistered event: missing brokerClientID. Body: %+v", bodyMap)
		return nil, nil
	}

	if pageSessionIDVal, loaded := m.brokerToPage.LoadAndDelete(brokerClientID); loaded {
		if pageSessionID, ok := pageSessionIDVal.(string); ok {
			m.pageToBroker.Delete(pageSessionID)
			m.logger.Info("SessionManager: Deregistered session for BrokerClientID: %s (was PageSessionID: %s)", brokerClientID, pageSessionID)
		}
	} else {
		m.logger.Warn("SessionManager: Received deregistration for unknown BrokerClientID: %s", brokerClientID)
	}
	return nil, nil
}

// GetBrokerClientID retrieves the BrokerClientID for a given PageSessionID.
func (m *Manager) GetBrokerClientID(pageSessionID string) (string, bool) {
	if pageSessionID == "" {
		return "", false
	}
	val, ok := m.pageToBroker.Load(pageSessionID)
	if !ok {
		return "", false
	}
	brokerID, ok := val.(string)
	return brokerID, ok
}

// GetPageSessionID retrieves the PageSessionID for a given BrokerClientID.
func (m *Manager) GetPageSessionID(brokerClientID string) (string, bool) {
	if brokerClientID == "" {
		return "", false
	}
	val, ok := m.brokerToPage.Load(brokerClientID)
	if !ok {
		return "", false
	}
	pageID, ok := val.(string)
	return pageID, ok
}
```

**File: cmd/rpcserver/api/handler.go**
```go
// cmd/rpcserver/api/handler.go
package api

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/lightforgemedia/go-websocketmq" // Import the updated library
	"github.com/lightforgemedia/go-websocketmq/cmd/rpcserver/session"
)

// RequestPayload is the expected JSON structure for API requests.
type RequestPayload struct {
	SessionID string                 `json:"sessionId"`
	Selector  string                 `json:"selector,omitempty"`
	Text      string                 `json:"text,omitempty"`
	URL       string                 `json:"url,omitempty"`
	Params    map[string]interface{} `json:"params,omitempty"` // For generic actions
}

// Response is a generic JSON response structure.
type Response struct {
	Success bool        `json:"success"`
	Message string      `json:"message,omitempty"`
	Data    interface{} `json:"data,omitempty"`
	Error   string      `json:"error,omitempty"`
}

// Handler provides HTTP handlers for API endpoints.
type Handler struct {
	logger         websocketmq.Logger
	broker         websocketmq.Broker
	sessionManager *session.Manager
	requestTimeout time.Duration
}

// NewHandler creates a new API handler.
func NewHandler(logger websocketmq.Logger, broker websocketmq.Broker, sm *session.Manager) *Handler {
	return &Handler{
		logger:         logger,
		broker:         broker,
		sessionManager: sm,
		requestTimeout: 15 * time.Second, // Default timeout for browser actions
	}
}

func (h *Handler) sendJSONResponse(w http.ResponseWriter, statusCode int, payload interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	if err := json.NewEncoder(w).Encode(payload); err != nil {
		h.logger.Error("API Handler: Failed to encode JSON response: %v", err)
	}
}

// HandleAction is a generic handler for various browser actions.
// The action name (e.g., "browser.click", "browser.input") is passed as a parameter.
func (h *Handler) HandleAction(actionName string) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			h.sendJSONResponse(w, http.StatusMethodNotAllowed, Response{Success: false, Error: "Method not allowed"})
			return
		}

		var payload RequestPayload
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			h.sendJSONResponse(w, http.StatusBadRequest, Response{Success: false, Error: "Invalid JSON payload: " + err.Error()})
			return
		}
		defer r.Body.Close()

		if payload.SessionID == "" {
			h.sendJSONResponse(w, http.StatusBadRequest, Response{Success: false, Error: "sessionId is required"})
			return
		}

		brokerClientID, found := h.sessionManager.GetBrokerClientID(payload.SessionID)
		if !found {
			h.logger.Warn("API Handler: No active client found for SessionID: %s", payload.SessionID)
			h.sendJSONResponse(w, http.StatusNotFound, Response{Success: false, Error: "Client session not found or not active"})
			return
		}

		// Prepare parameters for the browser action
		actionParams := make(map[string]interface{})
		if payload.Selector != "" {
			actionParams["selector"] = payload.Selector
		}
		if payload.Text != "" {
			actionParams["text"] = payload.Text
		}
		if payload.URL != "" {
			actionParams["url"] = payload.URL
		}
		// Merge generic params if any
		if payload.Params != nil {
			for k, v := range payload.Params {
				actionParams[k] = v
			}
		}
		if len(actionParams) == 0 && actionName != "browser.screenshot" && actionName != "browser.getPageSource" { // Some actions might not need params
			// For actions like click, selector is usually required. This is a basic check.
			// Specific validation should happen based on actionName.
			// h.sendJSONResponse(w, http.StatusBadRequest, Response{Success: false, Error: "Missing required parameters for action: " + actionName})
			// return
			h.logger.Debug("API Handler: Action %s called with no specific params, using empty map.", actionName)
		}


		// Create the request message for the client
		// The Topic is the action name the client is subscribed to.
		requestMsg := websocketmq.NewRequest(actionName, actionParams, int64(h.requestTimeout/time.Millisecond))

		h.logger.Info("API Handler: Sending action '%s' to BrokerClientID: %s (PageSessionID: %s) with params: %+v",
			actionName, brokerClientID, payload.SessionID, actionParams)

		responseMsg, err := h.broker.RequestToClient(r.Context(), brokerClientID, requestMsg, int64(h.requestTimeout/time.Millisecond))

		if err != nil {
			h.logger.Error("API Handler: Error calling RequestToClient for action '%s' on client %s: %v", actionName, brokerClientID, err)
			errMsg := "Failed to execute action on client"
			if err == websocketmq.ErrClientNotFound {
				errMsg = "Client disconnected or not found"
				// Proactively try to clean up session if client is not found by broker
				mngPageID, _ := h.sessionManager.GetPageSessionID(brokerClientID)
				if mngPageID == payload.SessionID { // ensure it's the same session we are trying to remove
					// This might be redundant if broker's DeregisterConnection already published an event
					// but serves as a fallback.
					h.logger.Info("API Handler: Client %s not found by broker, attempting to remove from session manager.", brokerClientID)
					// Directly removing here. Ideally, this is handled by broker disconnect events.
					// m.sessionManager.RemoveByBrokerClientID(brokerClientID)
				}
			} else if err == websocketmq.ErrRequestTimeout {
				errMsg = "Action timed out on client"
			} else if err == websocketmq.ErrConnectionWrite {
				errMsg = "Failed to send action to client (connection issue)"
			}
			h.sendJSONResponse(w, http.StatusInternalServerError, Response{Success: false, Error: errMsg, Data: fmt.Sprintf("Details: %v", err)})
			return
		}

		// Check if the response from the client indicates an error
		if responseMsg.Header.Type == "error" {
			h.logger.Warn("API Handler: Action '%s' on client %s resulted in an error: %+v", actionName, brokerClientID, responseMsg.Body)
			var clientErrorMsg string
			if errMap, ok := responseMsg.Body.(map[string]interface{}); ok {
				if errMsg, ok := errMap["error"].(string); ok {
					clientErrorMsg = errMsg
				} else if errStr, ok := errMap["message"].(string); ok { // some errors might use "message"
					clientErrorMsg = errStr
				}
			}
			if clientErrorMsg == "" {
				clientErrorMsg = "Unknown error from client execution"
			}
			h.sendJSONResponse(w, http.StatusOK, Response{Success: false, Message: "Action resulted in an error on the client", Error: clientErrorMsg, Data: responseMsg.Body})
			return
		}

		h.logger.Info("API Handler: Action '%s' successful for client %s. Response: %+v", actionName, brokerClientID, responseMsg.Body)
		h.sendJSONResponse(w, http.StatusOK, Response{Success: true, Message: "Action executed successfully", Data: responseMsg.Body})
	}
}
```

**File: cmd/rpcserver/main.go**
```go
// cmd/rpcserver/main.go
package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/lightforgemedia/go-websocketmq"
	"github.com/lightforgemedia/go-websocketmq/cmd/rpcserver/api"
	"github.com/lightforgemedia/go-websocketmq/cmd/rpcserver/session"
)

// Simple logger implementation for the example
type AppLogger struct{}

func (l *AppLogger) Debug(msg string, args ...any) { log.Printf("DEBUG: "+msg, args...) }
func (l *AppLogger) Info(msg string, args ...any)  { log.Printf("INFO: "+msg, args...) }
func (l *AppLogger) Warn(msg string, args ...any)  { log.Printf("WARN: "+msg, args...) }
func (l *AppLogger) Error(msg string, args ...any) { log.Printf("ERROR: "+msg, args...) }

func main() {
	logger := &AppLogger{}
	logger.Info("Starting RPC WebSocketMQ Server...")

	// 1. Initialize Broker
	brokerOpts := websocketmq.DefaultBrokerOptions()
	broker := websocketmq.NewPubSubBroker(logger, brokerOpts)
	// Cast to access specific ps.PubSubBroker methods if needed for shutdown, e.g. WaitForShutdown
	// psBroker, _ := broker.(*ps.PubSubBroker) // Assuming ps is the concrete type

	// 2. Initialize Session Manager
	// The session manager needs the broker to listen to registration/deregistration events.
	sessionManager := session.NewManager(logger, broker)
	logger.Info("Session Manager initialized.")

	// 3. Initialize WebSocket Handler
	wsHandlerOpts := websocketmq.DefaultHandlerOptions()
	wsHandlerOpts.ClientRegisterTopic = "_client.register" // Ensure this matches JS client
	wsHandler := websocketmq.NewWebSocketHandler(broker, logger, wsHandlerOpts)
	logger.Info("WebSocket Handler initialized.")

	// 4. Initialize API Handler
	apiHandler := api.NewHandler(logger, broker, sessionManager)
	logger.Info("API Handler initialized.")

	// 5. Setup HTTP routes
	mux := http.NewServeMux()
	mux.Handle("/ws", wsHandler) // WebSocket connections
	mux.Handle("/wsmq/", http.StripPrefix("/wsmq/", websocketmq.ScriptHandler())) // Serve JS client

	// API routes for browser actions
	mux.HandleFunc("/api/click", apiHandler.HandleAction("browser.click"))
	mux.HandleFunc("/api/input", apiHandler.HandleAction("browser.input"))
	mux.HandleFunc("/api/navigate", apiHandler.HandleAction("browser.navigate"))
	mux.HandleFunc("/api/getText", apiHandler.HandleAction("browser.getText"))
	mux.HandleFunc("/api/screenshot", apiHandler.HandleAction("browser.screenshot"))
	// Add more actions as needed...

	// Serve static files for the example UI
	mux.Handle("/", http.FileServer(http.Dir("./cmd/rpcserver/static")))
	logger.Info("HTTP routes configured.")

	// Example server-side subscription (not directly related to RPC, but shows broker usage)
	broker.Subscribe(context.Background(), "server.ping", func(ctx context.Context, msg *websocketmq.Message, sourceBrokerID string) (*websocketmq.Message, error) {
		logger.Info("Received server.ping from source %s: %+v", sourceBrokerID, msg.Body)
		return websocketmq.NewResponse(msg, map[string]string{"reply": "pong from server handler"}), nil
	})

	// 6. Start HTTP server
	server := &http.Server{
		Addr:    ":9000",
		Handler: mux,
	}

	go func() {
		logger.Info("RPC Server listening on http://localhost:9000")
		fmt.Println("--- Open http://localhost:9000 in your browser to see the example ---")
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			logger.Error("HTTP server ListenAndServe error: %v", err)
			os.Exit(1)
		}
	}()

	// 7. Graceful shutdown
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	logger.Info("Shutting down server...")

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := server.Shutdown(ctx); err != nil {
		logger.Error("HTTP server shutdown error: %v", err)
	}

	// Close the broker (which should also handle closing connections and subscriptions)
	if err := broker.Close(); err != nil {
		logger.Error("Broker close error: %v", err)
	}
	// if psBroker != nil {
	// 	psBroker.WaitForShutdown() // If you have such a method
	// }

	logger.Info("Server gracefully stopped.")
}
```

**File: cmd/rpcserver/static/browser_automation_mock.js**
```javascript
// cmd/rpcserver/static/browser_automation_mock.js

// This is a MOCK implementation of browser automation functions
// for the example project. In a real scenario, this would interact
// with Puppeteer, Playwright, or similar.

window.BrowserAutomationMock = {
    logAction: function(action, params, result) {
        const logEntry = document.createElement('div');
        const timestamp = new Date().toLocaleTimeString();
        logEntry.innerHTML = `<strong>[${timestamp}] ${action}</strong>: Params: <code>${JSON.stringify(params)}</code> <br/>&nbsp;&nbsp;&nbsp;Result: <code>${JSON.stringify(result)}</code>`;
        document.getElementById('action-log').prepend(logEntry);
    },

    click: async function(params) {
        return new Promise(resolve => {
            const { selector } = params;
            const result = { success: true, message: `Mock clicked element: ${selector}` };
            this.logAction('browser.click', params, result);

            // Simulate UI change
            const statusEl = document.getElementById('click-status');
            if (statusEl) {
                statusEl.textContent = `Clicked ${selector} at ${new Date().toLocaleTimeString()}`;
                statusEl.style.color = 'green';
            }
            setTimeout(() => resolve(result), 200); // Simulate async operation
        });
    },

    input: async function(params) {
        return new Promise(resolve => {
            const { selector, text } = params;
            const result = { success: true, message: `Mock inputted '${text}' into element: ${selector}` };
            this.logAction('browser.input', params, result);

            // Simulate UI change
            const statusEl = document.getElementById('input-status');
            if (statusEl) {
                statusEl.textContent = `Inputted "${text}" into ${selector} at ${new Date().toLocaleTimeString()}`;
                statusEl.style.color = 'blue';
            }
            const inputTarget = document.querySelector(selector);
            if (inputTarget && typeof inputTarget.value !== 'undefined') {
                inputTarget.value = text;
            }

            setTimeout(() => resolve(result), 300);
        });
    },

    navigate: async function(params) {
        return new Promise(resolve => {
            const { url } = params;
            const result = { success: true, message: `Mock navigated to URL: ${url}`, newUrl: url };
            this.logAction('browser.navigate', params, result);
            
            const statusEl = document.getElementById('navigate-status');
            if (statusEl) {
                statusEl.textContent = `Navigated to ${url} at ${new Date().toLocaleTimeString()}`;
                statusEl.style.color = 'purple';
            }
            // In a real scenario, this would change window.location or iframe src
            setTimeout(() => resolve(result), 500);
        });
    },

    getText: async function(params) {
        return new Promise(resolve => {
            const { selector } = params;
            let textContent = `Mock text from ${selector}`;
            try {
                const el = document.querySelector(selector);
                if (el) {
                    textContent = el.textContent || el.innerText || el.value || `Mock text from ${selector}`;
                }
            } catch (e) { /* ignore for mock */ }
            
            const result = { success: true, text: textContent };
            this.logAction('browser.getText', params, result);
            setTimeout(() => resolve(result), 100);
        });
    },

    screenshot: async function(params) {
        return new Promise(resolve => {
            const result = { success: true, message: "Mock screenshot taken", imageDataBase64: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" }; // 1x1 black pixel
            this.logAction('browser.screenshot', params, result);
             const statusEl = document.getElementById('screenshot-status');
            if (statusEl) {
                statusEl.innerHTML = `Screenshot taken at ${new Date().toLocaleTimeString()}. <img src="${result.imageDataBase64}" alt="mock screenshot" width="50"/>`;
                statusEl.style.color = 'orange';
            }
            setTimeout(() => resolve(result), 400);
        });
    }
};
```

**File: cmd/rpcserver/static/index.html**
```html
<!-- cmd/rpcserver/static/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocketMQ RPC Demo</title>
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    <h1>WebSocketMQ RPC Browser Automation Demo</h1>

    <div class="card">
        <h2>Connection</h2>
        <p>Page Session ID: <strong id="page-session-id">Generating...</strong></p>
        <p>Status: <span id="connection-status" class="disconnected">Disconnected</span></p>
        <button id="connect-btn">Connect</button>
        <button id="disconnect-btn">Disconnect</button>
    </div>

    <div class="card">
        <h2>API Triggered Actions</h2>
        <p>These buttons will make HTTP API calls to the server, which will then send RPC commands to this browser client.</p>
        
        <div>
            <button id="api-click-btn">API: Click #test-button-1</button>
            <span id="click-status"></span>
        </div>
        <div style="margin-top: 10px;">
            <input type="text" id="api-input-text" value="Hello from API!" placeholder="Text to input">
            <button id="api-input-btn">API: Input into #test-input</button>
            <span id="input-status"></span>
        </div>
        <div style="margin-top: 10px;">
            <input type="text" id="api-navigate-url" value="https://example.com/mock" placeholder="URL to navigate">
            <button id="api-navigate-btn">API: Navigate</button>
            <span id="navigate-status"></span>
        </div>
         <div style="margin-top: 10px;">
            <button id="api-screenshot-btn">API: Screenshot</button>
            <span id="screenshot-status"></span>
        </div>
        <hr/>
        <h4>Test Elements:</h4>
        <button id="test-button-1" onclick="alert('Test Button 1 Clicked Locally!')">Test Button 1</button>
        <input type="text" id="test-input" placeholder="Test Input Field">
        <p id="test-paragraph">This is a paragraph with some <strong>bold text</strong> to get.</p>
         <button id="api-gettext-btn">API: Get Text from #test-paragraph</button>
    </div>
    
    <div class="card">
        <h2>Client-Initiated Request (to Server Handler)</h2>
        <button id="client-ping-server">Ping Server (Topic: server.ping)</button>
        <div id="client-ping-response"></div>
    </div>


    <div class="card">
        <h2>Action Log (Client-Side)</h2>
        <div id="action-log" class="message-log"></div>
    </div>
    
    <div class="card">
        <h2>WebSocket Message Log</h2>
        <div id="messages" class="message-log"></div>
    </div>


    <script src="/wsmq/websocketmq.js"></script> <!-- Use the library -->
    <script src="/browser_automation_mock.js"></script>

    <script>
        const pageSessionIdDisplay = document.getElementById('page-session-id');
        const connectionStatus = document.getElementById('connection-status');
        const connectBtn = document.getElementById('connect-btn');
        const disconnectBtn = document.getElementById('disconnect-btn');
        const messagesContainer = document.getElementById('messages');
        const actionLogContainer = document.getElementById('action-log');

        let pageSessionID = localStorage.getItem('wsmqPageSessionID');
        if (!pageSessionID) {
            pageSessionID = 'page-' + Date.now().toString(36) + Math.random().toString(36).substring(2, 10);
            localStorage.setItem('wsmqPageSessionID', pageSessionID);
        }
        pageSessionIdDisplay.textContent = pageSessionID;

        function addMessageToLog(container, type, title, content) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type}-message`;
            const titleEl = document.createElement('strong');
            titleEl.textContent = `[${new Date().toLocaleTimeString()}] ${title}`;
            const contentEl = document.createElement('pre');
            contentEl.textContent = (typeof content === 'object') ? JSON.stringify(content, null, 2) : String(content);
            
            messageEl.appendChild(titleEl);
            messageEl.appendChild(document.createElement('br'));
            messageEl.appendChild(contentEl);
            container.prepend(messageEl); // Prepend to see latest on top
        }
        
        const clientLogger = {
            debug: (...args) => { console.debug(...args); addMessageToLog(messagesContainer, 'debug', 'WSMQ Client DEBUG', args.join(' ')); },
            info: (...args) => { console.info(...args); addMessageToLog(messagesContainer, 'info', 'WSMQ Client INFO', args.join(' ')); },
            warn: (...args) => { console.warn(...args); addMessageToLog(messagesContainer, 'warn', 'WSMQ Client WARN', args.join(' ')); },
            error: (...args) => { console.error(...args); addMessageToLog(messagesContainer, 'error', 'WSMQ Client ERROR', args.join(' ')); }
        };

        const client = new WebSocketMQ.Client({
            url: `ws://${window.location.host}/ws`,
            reconnect: true,
            devMode: true,
            logger: clientLogger,
            pageSessionID: pageSessionID, // Provide the PageSessionID for registration
            clientRegisterTopic: "_client.register" // Default, but explicit
        });

        client.onConnect(() => {
            connectionStatus.textContent = 'Connected';
            connectionStatus.className = 'connected';
            addMessageToLog(messagesContainer, 'event', 'Connection Event', 'Connected to WebSocketMQ server');
        });

        client.onDisconnect((event) => {
            connectionStatus.textContent = 'Disconnected';
            connectionStatus.className = 'disconnected';
            addMessageToLog(messagesContainer, 'event', 'Connection Event', `Disconnected. Code: ${event.code}, Clean: ${event.wasClean}`);
        });

        client.onError((err, rawEvent) => {
            addMessageToLog(messagesContainer, 'error', 'WebSocket Error', err.message || 'Unknown WebSocket error');
            if (rawEvent) console.error("Raw WebSocket error event:", rawEvent);
        });

        // Register handlers for actions initiated by the server
        client.subscribe("browser.click", async (params, originalMessage) => {
            addMessageToLog(actionLogContainer, 'request', 'Received RPC: browser.click', params);
            const result = await window.BrowserAutomationMock.click(params);
            addMessageToLog(actionLogContainer, 'response', 'Responding to RPC: browser.click', result);
            return result; // This will be sent back as the response
        });

        client.subscribe("browser.input", async (params, originalMessage) => {
            addMessageToLog(actionLogContainer, 'request', 'Received RPC: browser.input', params);
            const result = await window.BrowserAutomationMock.input(params);
            addMessageToLog(actionLogContainer, 'response', 'Responding to RPC: browser.input', result);
            return result;
        });

        client.subscribe("browser.navigate", async (params, originalMessage) => {
            addMessageToLog(actionLogContainer, 'request', 'Received RPC: browser.navigate', params);
            const result = await window.BrowserAutomationMock.navigate(params);
            addMessageToLog(actionLogContainer, 'response', 'Responding to RPC: browser.navigate', result);
            return result;
        });
        
        client.subscribe("browser.getText", async (params, originalMessage) => {
            addMessageToLog(actionLogContainer, 'request', 'Received RPC: browser.getText', params);
            const result = await window.BrowserAutomationMock.getText(params);
            addMessageToLog(actionLogContainer, 'response', 'Responding to RPC: browser.getText', result);
            return result;
        });

        client.subscribe("browser.screenshot", async (params, originalMessage) => {
            addMessageToLog(actionLogContainer, 'request', 'Received RPC: browser.screenshot', params);
            const result = await window.BrowserAutomationMock.screenshot(params);
            addMessageToLog(actionLogContainer, 'response', 'Responding to RPC: browser.screenshot', result);
            return result;
        });


        // --- UI Event Handlers to trigger API calls ---
        async function callApi(endpoint, body) {
            try {
                addMessageToLog(actionLogContainer, 'api-call', `API Call to ${endpoint}`, body);
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const result = await response.json();
                addMessageToLog(actionLogContainer, response.ok && result.success ? 'api-success' : 'api-error', `API Response from ${endpoint}`, result);
                return result;
            } catch (error) {
                addMessageToLog(actionLogContainer, 'api-error', `API Call Error ${endpoint}`, error.message);
                console.error(`API call to ${endpoint} failed:`, error);
                return { success: false, error: error.message };
            }
        }

        document.getElementById('api-click-btn').addEventListener('click', () => {
            callApi('/api/click', { sessionId: pageSessionID, selector: '#test-button-1' });
        });

        document.getElementById('api-input-btn').addEventListener('click', () => {
            const text = document.getElementById('api-input-text').value;
            callApi('/api/input', { sessionId: pageSessionID, selector: '#test-input', text: text });
        });

        document.getElementById('api-navigate-btn').addEventListener('click', () => {
            const url = document.getElementById('api-navigate-url').value;
            callApi('/api/navigate', { sessionId: pageSessionID, url: url });
        });
        
        document.getElementById('api-gettext-btn').addEventListener('click', () => {
            callApi('/api/getText', { sessionId: pageSessionID, selector: '#test-paragraph' });
        });
        
        document.getElementById('api-screenshot-btn').addEventListener('click', () => {
            callApi('/api/screenshot', { sessionId: pageSessionID });
        });
        
        // Client-initiated request
        document.getElementById('client-ping-server').addEventListener('click', () => {
            const pingPayload = { data: "ping from client", time: new Date().toISOString() };
            addMessageToLog(messagesContainer, 'request', 'Client Request: server.ping', pingPayload);
            client.request("server.ping", pingPayload, 3000)
                .then(response => {
                    addMessageToLog(messagesContainer, 'response', 'Server Response (to server.ping)', response);
                    document.getElementById('client-ping-response').textContent = `Server Pong: ${JSON.stringify(response)}`;
                })
                .catch(err => {
                    addMessageToLog(messagesContainer, 'error', 'Server Ping Error', err.message);
                     document.getElementById('client-ping-response').textContent = `Ping Error: ${err.message}`;
                });
        });


        connectBtn.addEventListener('click', () => client.connect());
        disconnectBtn.addEventListener('click', () => client.disconnect());

        // Auto-connect on load
        client.connect();

    </script>
</body>
</html>
```

**File: cmd/rpcserver/static/style.css**
```css
/* cmd/rpcserver/static/style.css */
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    max-width: 900px;
    margin: 20px auto;
    padding: 0 20px;
    line-height: 1.6;
    background-color: #f4f7f6;
    color: #333;
}

h1, h2, h3, h4 {
    color: #2c3e50;
}
h1 {
    border-bottom: 2px solid #3498db;
    padding-bottom: 10px;
    text-align: center;
}

.card {
    background: #ffffff;
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 25px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.05);
    border-left: 5px solid #3498db;
}
.card:nth-child(odd) {
    border-left-color: #1abc9c;
}


button {
    background-color: #3498db;
    color: white;
    border: none;
    padding: 10px 18px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 15px;
    margin-right: 10px;
    transition: background-color 0.2s ease;
}
button:hover {
    background-color: #2980b9;
}
button:disabled {
    background-color: #bdc3c7;
    cursor: not-allowed;
}
#disconnect-btn {
    background-color: #e74c3c;
}
#disconnect-btn:hover {
    background-color: #c0392b;
}


input[type="text"], input[type="number"] {
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    font-size: 14px;
    margin-right: 10px;
    min-width: 200px;
}

#connection-status { font-weight: bold; }
.connected { color: #2ecc71; }
.disconnected { color: #e74c3c; }

.message-log {
    height: 250px;
    overflow-y: auto;
    border: 1px solid #ecf0f1;
    border-radius: 5px;
    padding: 15px;
    margin-top: 15px;
    background-color: #fdfefe;
    font-size: 0.9em;
}
.message {
    margin-bottom: 10px;
    padding: 8px 12px;
    border-radius: 4px;
    border-left-width: 4px;
    border-left-style: solid;
}
.message strong {
    display: block;
    margin-bottom: 4px;
}
.message pre {
    background: #e8eef1;
    padding: 8px;
    border-radius: 3px;
    overflow-x: auto;
    margin: 5px 0 0 0;
    font-family: 'Courier New', Courier, monospace;
    font-size: 0.95em;
    word-break: break-all;
}

/* Message types for WebSocket Log */
.message.debug-message { border-left-color: #7f8c8d; background-color: #f8f9f9; }
.message.info-message { border-left-color: #3498db; background-color: #eaf5fc; }
.message.warn-message { border-left-color: #f39c12; background-color: #fef5e7; }
.message.error-message { border-left-color: #e74c3c; background-color: #fdedec; }
.message.event-message { border-left-color: #1abc9c; background-color: #e8f8f5; }
.message.request-message { border-left-color: #9b59b6; background-color: #f4ecf7; }
.message.response-message { border-left-color: #2ecc71; background-color: #eafaf1; }

/* Message types for Action Log */
.message.api-call-message { border-left-color: #8e44ad; background-color: #f3eef5; }
.message.api-success-message { border-left-color: #27ae60; background-color: #e9f7ef; }
.message.api-error-message { border-left-color: #c0392b; background-color: #faeaea; }

hr {
    border: 0;
    height: 1px;
    background-color: #ecf0f1;
    margin: 20px 0;
}
```

---

**To Run This Example Project:**

1.  Ensure all the `go-websocketmq` library files (from Phase 1 and the `websocketmq.go` facade) are correctly placed in your `GOPATH` or Go modules structure.
2.  Navigate to the `cmd/rpcserver` directory.
3.  Run `go mod init rpcserver` (or your chosen module name).
4.  Run `go mod tidy` to fetch dependencies (like `github.com/lightforgemedia/go-websocketmq`).
5.  Run `go run main.go`.
6.  Open `http://localhost:9000` in your browser.

You should see the demo page. You can:
*   Connect/disconnect the WebSocket.
*   See the `PageSessionID` being registered.
*   Click the "API: Click #test-button-1" (and other API buttons). This will:
    *   Send an HTTP POST to the Go server.
    *   The Go server's API handler will look up your `PageSessionID` to get the `BrokerClientID`.
    *   It will use `broker.RequestToClient` to send a message (e.g., `Topic: "browser.click"`) to your specific browser instance.
    *   Your browser's JavaScript `client.subscribe("browser.click", ...)` handler will execute `BrowserAutomationMock.click()`.
    *   The result from the mock will be sent back to the server.
    *   The server's API handler will receive this result and send it back as the HTTP response.
    *   The Action Log on the page will show these steps.
*   The WebSocket Message Log will show the raw client library logs.

This example demonstrates the end-to-end RPC flow using the enhanced `go-websocketmq` library.