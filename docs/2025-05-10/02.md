**Comprehensive Test Plan Specification (Generated via Recursive Self-Learning)**

**Generated:** 2025-05-10T21:00:00Z
**Codebase Language:** Go
**Analysis Scope:** Full codebase static analysis with iterative refinement, focusing on the provided `server/main.go` and `client/main.go` application snippets and their usage of an assumed ErgoSockets library.

**1. Executive Summary & Strategy**

The provided codebase consists of two Go applications: a server (`server/main.go`) and a client (`client/main.go`). These applications demonstrate the high-level API usage of a hypothetical "ErgoSockets" WebSocket library for real-time communication. The server initializes a broker, registers handlers for specific request topics (`system:get_time`, `user:get_details`), and periodically publishes announcements on another topic (`server:announcements`). The client connects to the server, makes requests, subscribes to announcements, and handles server-initiated requests (`client:get_status`). Both applications utilize a shared types package (`shared_types`) for message structures and topic constants.

The architecture is event-driven, centered around topic-based messaging and request-response patterns facilitated by the ErgoSockets library. The application code itself is minimal, primarily defining handlers and orchestrating calls to the library.

**Top 3-5 Highest-Risk Areas (Iteratively Refined):**

1.  **Client-Server Request/Response Integrity (`system:get_time`, `user:get_details`):** Ensuring that requests sent by the client are correctly received and processed by the server's designated `OnRequest` handler, and that the server's response is correctly received and unmarshalled by the client. *Initial thought was just "request handling," but refinement identified the full round-trip data integrity as the key risk.*
2.  **Server-Side Publish to Client Subscription Integrity (`server:announcements`):** Verifying that messages published by the server on a topic are received by all subscribed clients and correctly processed by their `Subscribe` handlers. *Refinement: The risk isn't just the publish or subscribe call, but the end-to-end flow and data consistency.*
3.  **Server-to-Client Request/Response Integrity (`client:get_status`):** Validating the less common but critical pattern where the server initiates a request to a specific client, and the client's `OnRequest` handler processes it and responds. *This was elevated in priority after evaluating its distinct interaction pattern compared to client-initiated requests.*
4.  **Correct Invocation and Error Handling of Library APIs:** Given that the application logic is thin, a significant risk lies in the correct usage of the ErgoSockets library APIs (e.g., `cli.Request`, `broker.OnRequest`, `cli.Subscribe`, `broker.Publish`) and how the application code handles potential errors returned by these library calls. *Initially, I focused on handler logic, but recursive evaluation highlighted that the interaction points with the library are where most application-level failures related to communication would originate.*

**Overall Testing Strategy:**

The testing strategy will heavily emphasize **Integration Testing** due to the nature of the codebase, which primarily demonstrates interactions with the ErgoSockets library.

*   **Unit Tests:** Will focus on the isolated logic *within* the callback handlers provided to the ErgoSockets library (e.g., the functions passed to `broker.OnRequest`, `cli.Subscribe`, `cli.OnRequest`). These tests will mock the ErgoSockets library's invocation of these handlers.
*   **Integration Tests:** These will be the cornerstone. They will test the interactions between the client application snippet and the server application snippet *through* a conceptual (or actual, if available for testing) ErgoSockets layer. This involves verifying that data sent by one side is correctly received and processed by the other for all defined communication patterns (request/response, pub/sub, server-to-client request).
*   **End-to-End (E2E) Tests:** For this specific codebase, E2E tests will closely resemble comprehensive integration tests. They would involve running the actual `server/main.go` and `client/main.go` programs and asserting their interactions. The distinction is subtle here due to the lack of complex UI or multiple external services in the provided snippets.

**Recursive Analysis Impact:** Initial analysis might have suggested more traditional unit tests for each function. However, deeper evaluation of the code's structure (thin application logic, heavy reliance on library calls) shifted the focus. The "units" of behavior are more accurately the *handlers* and their correct invocation and data processing, while the *interactions* between client and server via the library are paramount. This led to prioritizing integration tests that cover these interaction patterns.

**Key Areas Requiring Mocking:**
For focused unit tests of handlers:
*   The `broker.ClientHandle` interface (for server-side handlers).
*   The `client.Client` interface (or relevant parts, for client-side handlers if they were to take `cli` as an argument, though current examples don't show this).
For integration tests (if not running full E2E):
*   The ErgoSockets library itself might be replaced with a test double or an in-memory version if the goal is to test the application logic's interaction *contracts* without network dependencies. However, for these examples, testing with the actual (assumed) library is more aligned with verifying usage.

**Limitations Note:**
This test plan is based on static analysis of the provided Go application snippets and their apparent usage of an assumed ErgoSockets library. It cannot cover:
*   Runtime behavior under specific OS/network conditions not inferable from code structure.
*   Specific data-driven edge cases not obvious from the code's structure (e.g., malformed JSON payloads if not handled by the library).
*   Requirement mismatches (i.e., if the code implements something different from an unstated requirement).
*   Performance, load, or security vulnerabilities beyond basic structural inferences.
*   The internal correctness of the ErgoSockets library itself; this plan focuses on the *application's usage* of the library.

**2. Prioritized Unit Test Specifications**

*(Note: "Unit" here refers to testing the application's handler logic in isolation, assuming the ErgoSockets library correctly invokes it.)*

**Target Entity:** `server/main.go` - `broker.OnRequest(app_shared_types.TopicGetTime, handlerFunc)`
**Priority:** Critical
**Rationale:** Core server functionality (request/response). Handler logic is simple but foundational. Refined analysis indicates this is a primary interaction pattern.
**Suggested Test Cases/Scenarios (Refined & Specific):**
1.  **Happy Path:**
    *   Simulate invocation with a valid `broker.ClientHandle` and `app_shared_types.GetTimeRequest`.
    *   Assert that the returned `app_shared_types.GetTimeResponse.CurrentTime` is a correctly formatted timestamp (RFC3339).
    *   Assert that no error is returned.
2.  **Logging Verification:**
    *   Assert that the expected log message (`Server: Client %s requested time.`) is generated with the correct client ID.
**Mocking Needs:**
*   `broker.ClientHandle` (to provide `ID()`).
**State Verification (if applicable):** N/A

**Target Entity:** `server/main.go` - `broker.OnRequest(app_shared_types.TopicUserDetails, handlerFunc)`
**Priority:** Critical
**Rationale:** Core server functionality (request/response with payload). Demonstrates data handling.
**Suggested Test Cases/Scenarios (Refined & Specific):**
1.  **Happy Path (User Found):**
    *   Simulate invocation with `app_shared_types.GetUserDetailsRequest{UserID: "user123"}`.
    *   Assert that the returned `app_shared_types.UserDetailsResponse` contains the expected static data (`Name: "Jane Doe", Email: "jane@example.com"`).
    *   Assert no error.
2.  **Logging Verification:**
    *   Assert that the expected log message is generated.
*(Note: The current example doesn't have a "user not found" path in the handler, but if it did, that would be another critical scenario.)*
**Mocking Needs:**
*   `broker.ClientHandle`.
**State Verification (if applicable):** N/A

**Target Entity:** `client/main.go` - `cli.Subscribe[app_shared_types.ServerAnnouncement](app_shared_types.TopicServerAnnounce, handlerFunc)`
**Priority:** Critical
**Rationale:** Core client functionality (receiving server pushes). Handler logic is simple but vital for this pattern.
**Suggested Test Cases/Scenarios (Refined & Specific):**
1.  **Happy Path (Receive Announcement):**
    *   Simulate invocation with an `app_shared_types.ServerAnnouncement` payload.
    *   Assert that the expected log message (`Client: Announcement from Server: [%s] %s`) is generated with correct data.
    *   Assert no error is returned by the handler.
**Mocking Needs:** None directly for the handler logic itself, but the test setup would simulate the library calling this handler.
**State Verification (if applicable):** N/A

**Target Entity:** `client/main.go` - `cli.OnRequest(app_shared_types.TopicClientGetStatus, handlerFunc)`
**Priority:** High
**Rationale:** Demonstrates server-to-client RPC, a key bidirectional feature. Handler involves minimal state (`startTime`) and a library call (`cli.ID()`).
**Suggested Test Cases/Scenarios (Refined & Specific):**
1.  **Happy Path:**
    *   Simulate invocation with an `app_shared_types.ClientStatusQuery`.
    *   Assert that the returned `app_shared_types.ClientStatusReport` contains a `ClientID` (mocked from `cli.ID()`), `Status: "All systems nominal"`, and a valid `Uptime` string.
    *   Assert no error.
2.  **Logging Verification:**
    *   Assert that the expected log message is generated.
**Mocking Needs:**
*   A way to provide `cli.ID()` if the handler were tested in complete isolation from a `client.Client` instance.
*   A way to control `startTime` for predictable uptime calculation.
**State Verification (if applicable):** N/A

**3. Prioritized Integration Test Specifications**

*(These tests verify the interaction between the client and server snippets through the assumed ErgoSockets library.)*

**Integration Point:** Client Request Time -> Server Responds with Time
**Priority:** Critical
**Entities Involved:**
*   `client/main.go`: `cli.Request[app_shared_types.GetTimeResponse](app_shared_types.TopicGetTime)`
*   `server/main.go`: `broker.OnRequest(app_shared_types.TopicGetTime, ...)` handler
**Rationale:** Fundamental request-response pattern. Validates basic client-server communication and data marshalling/unmarshalling for a payload-less request. Refined analysis confirms this as a foundational interaction.
**Suggested Test Scenarios:**
1.  **Successful Time Retrieval:**
    *   Start server.
    *   Client connects and sends a `TopicGetTime` request.
    *   Assert client receives a `GetTimeResponse`.
    *   Assert `CurrentTime` field in response is a valid RFC3339 timestamp.
    *   Assert server logs the request from the client.
    *   Assert client logs the received time.
2.  **Client Handles Request Timeout (if library supports/exposes this):**
    *   Configure server handler for `TopicGetTime` to delay response beyond client's default timeout.
    *   Client sends request.
    *   Assert `cli.Request` returns a timeout error (or specific error type).
    *   Assert client logs the timeout error.
**Key Interactions to Verify:**
*   Client sends request on `app_shared_types.TopicGetTime`.
*   Server's `TopicGetTime` handler is invoked.
*   Server sends `app_shared_types.GetTimeResponse` back.
*   Client receives and correctly unmarshals `app_shared_types.GetTimeResponse`.

**Integration Point:** Client Request User Details -> Server Responds
**Priority:** Critical
**Entities Involved:**
*   `client/main.go`: `cli.Request[app_shared_types.UserDetailsResponse](app_shared_types.TopicUserDetails, detailsReq)`
*   `server/main.go`: `broker.OnRequest(app_shared_types.TopicUserDetails, ...)` handler
**Rationale:** Validates request-response with request and response payloads.
**Suggested Test Scenarios:**
1.  **Successful User Details Retrieval:**
    *   Start server.
    *   Client connects and sends a `TopicUserDetails` request with `UserID: "user123"`.
    *   Assert client receives a `UserDetailsResponse` with `Name: "Jane Doe", Email: "jane@example.com"`.
    *   Assert server logs the request.
    *   Assert client logs the received details.
**Key Interactions to Verify:**
*   Client sends `app_shared_types.GetUserDetailsRequest` on `app_shared_types.TopicUserDetails`.
*   Server's `TopicUserDetails` handler is invoked with correct payload.
*   Server sends `app_shared_types.UserDetailsResponse`.
*   Client receives and correctly unmarshals `app_shared_types.UserDetailsResponse`.

**Integration Point:** Server Publishes Announcement -> Client Receives Announcement
**Priority:** Critical
**Entities Involved:**
*   `server/main.go`: `ergoBroker.Publish(context.Background(), app_shared_types.TopicServerAnnounce, ...)`
*   `client/main.go`: `cli.Subscribe[app_shared_types.ServerAnnouncement](app_shared_types.TopicServerAnnounce, ...)` handler
**Rationale:** Fundamental publish-subscribe pattern. Validates server-initiated push to subscribed clients.
**Suggested Test Scenarios:**
1.  **Client Receives Published Announcement:**
    *   Start server.
    *   Client connects and subscribes to `TopicServerAnnounce`.
    *   Wait for server to publish an announcement (or trigger it).
    *   Assert client's subscription handler is invoked with the correct `ServerAnnouncement` data.
    *   Assert client logs the received announcement.
    *   Assert server logs the publishing action.
2.  **Multiple Clients Receive Announcement:**
    *   Start server.
    *   Start two or more clients; all connect and subscribe to `TopicServerAnnounce`.
    *   Wait for server to publish.
    *   Assert *all* clients' subscription handlers are invoked with the correct data.
**Key Interactions to Verify:**
*   Server publishes `app_shared_types.ServerAnnouncement` on `app_shared_types.TopicServerAnnounce`.
*   Client's `TopicServerAnnounce` subscription handler is invoked.
*   Client correctly unmarshals `app_shared_types.ServerAnnouncement`.

**Integration Point:** Server Requests Client Status -> Client Responds
**Priority:** High
**Entities Involved:**
*   Server-side (hypothetical invocation): `clientHandle.Request(...)` on `app_shared_types.TopicClientGetStatus`
*   `client/main.go`: `cli.OnRequest(app_shared_types.TopicClientGetStatus, ...)` handler
**Rationale:** Validates server-to-client request-response pattern.
**Suggested Test Scenarios:**
1.  **Client Successfully Responds to Status Request:**
    *   Start server.
    *   Client connects and registers its `TopicClientGetStatus` handler.
    *   Trigger server to send a `TopicClientGetStatus` request to the connected client (this might require a test hook in the server or a separate mechanism if not directly exposed in `server/main.go`).
    *   Assert client's `OnRequest` handler for `TopicClientGetStatus` is invoked with the `ClientStatusQuery`.
    *   Assert client logs the incoming request.
    *   Assert server (or test harness acting as server requester) receives the `ClientStatusReport` with correct `ClientID`, `Status`, and `Uptime`.
**Key Interactions to Verify:**
*   Server sends `app_shared_types.ClientStatusQuery` on `app_shared_types.TopicClientGetStatus` to a specific client.
*   Client's `TopicClientGetStatus` handler is invoked with the correct payload.
*   Client sends `app_shared_types.ClientStatusReport` back.
*   Server receives and correctly unmarshals `app_shared_types.ClientStatusReport`.

**Integration Point:** Client Connection Failure/Server Unavailable
**Priority:** High
**Entities Involved:**
*   `client/main.go`: `client.Connect(...)`
**Rationale:** Basic resilience check for client initialization.
**Suggested Test Scenarios:**
1.  **Connect Fails When Server is Down:**
    *   Ensure server is not running.
    *   Client attempts `client.Connect("ws://localhost:8080/ws")`.
    *   Assert `client.Connect` returns an error.
    *   Assert client logs the connection failure.
**Key Interactions to Verify:**
*   Error handling of the `client.Connect` call.

**4. Suggested End-to-End (E2E) Flow Specifications**

*(For this codebase, E2E flows largely overlap with comprehensive integration tests. They involve running both `server/main.go` and `client/main.go`.)*

**E2E Flow:** Full Client Lifecycle: Connect, Request Time, Request User Details, Receive Announcements, Handle Server Status Request
**Priority:** Critical
**Entry Point(s):** Client application starts, Server application starts.
**Key Components Involved (Refined Path):**
*   `client/main.go`: `main()`
*   `server/main.go`: `main()`
*   All ErgoSockets library interaction points in both client and server.
**Rationale:** Validates the primary demonstrated capabilities of the system working together. This flow covers most of the critical interactions identified.
**Suggested Scenarios:**
1.  **Successful Full Interaction:**
    *   Start `server/main.go`.
    *   Start `client/main.go`.
    *   Assert client successfully connects (client logs).
    *   Assert client successfully requests and receives time (client and server logs, client output).
    *   Assert client successfully requests and receives user details (client and server logs, client output).
    *   Wait for at least one server announcement. Assert client receives and logs it.
    *   (If testable) Trigger server to request client status. Assert client handles it and logs, and server (or test harness) confirms receipt of client status.
**Configuration Dependencies:** Server listens on `localhost:8080`. Client connects to `ws://localhost:8080/ws`.

**5. Regression Testing Scope Guidance (Based on Refined Dependency Analysis)**

**Guidance:** When modifying an entity in this codebase, the primary concern is its interaction with the ErgoSockets library and the corresponding entity on the other side (client/server).

*   **Changes to `shared_types` (e.g., modifying a struct field, adding a field, changing a topic constant):**
    *   **Impact:** Potentially affects both client and server wherever that type or topic is used.
    *   **Regression Scope:** All unit tests for handlers using that type. All integration tests involving that topic or data type. The full E2E test.
    *   **Rationale (Refined):** The `shared_types` package is a critical shared dependency. Changes here have a high likelihood of breaking the communication contract if not updated consistently on both sides. The refined dependency map shows direct usage across all major interaction points.

*   **Changes to a Server-Side `OnRequest` Handler Logic (e.g., in `server/main.go` for `TopicGetTime`):**
    *   **Impact:** Affects the server's processing for that specific topic. Downstream, it affects clients making requests to that topic.
    *   **Regression Scope:**
        *   Unit tests for that specific server handler.
        *   Integration test(s) for the client-server interaction on that topic.
        *   Relevant parts of the E2E test.
    *   **Rationale (Refined):** The change is localized to one server-side behavior, but its correctness is verified through client interaction.

*   **Changes to a Client-Side `cli.Request` Call or its `Subscribe`/`OnRequest` Handler Logic:**
    *   **Impact:** Affects the client's ability to initiate that request or handle that specific type of incoming message.
    *   **Regression Scope:**
        *   Unit tests for that specific client handler (if applicable).
        *   Integration test(s) for the client-server interaction involving that call/handler.
        *   Relevant parts of the E2E test.

**Example:**
If the `app_shared_types.GetTimeResponse` struct in `shared_types/types.go` is changed (e.g., `CurrentTime` field renamed to `ServerTimestamp`), the following regression tests are critical:
1.  Unit test for the server's `TopicGetTime` handler (to ensure it now populates `ServerTimestamp`).
2.  Integration test for "Client Request Time -> Server Responds with Time" (to ensure client can still make the request and correctly unmarshal the modified response).
3.  The full E2E test.
*Rationale (Refined):* This change breaks the data contract. The refined dependency map shows `GetTimeResponse` is used directly in the client's `cli.Request` call for unmarshalling and in the server's handler for marshalling. Failure to update both would lead to runtime unmarshalling errors.

**6. Specific Areas Requiring Attention (Identified through Refined Analysis)**

*   **Potential Test Coverage Gaps (Heuristic):**
    *   **Error Handling from Library Calls:** The example code primarily logs errors from ErgoSockets library calls (e.g., `cli.Request`, `cli.Subscribe`, `ergoBroker.Publish`). Tests should explicitly verify that these errors are indeed logged or handled as expected if more sophisticated error recovery were implemented. *Refinement: Initial pass focused on happy paths; recursive evaluation highlighted the need to systematically check application responses to library failures.*
    *   **Client `cli.ID()` Uniqueness/Format:** If `cli.ID()` is used for any critical logic beyond logging, its format or uniqueness might need verification (though this is more a library concern, the application relies on it).
    *   **Concurrent Client Connections (Server):** The current server example doesn't explicitly show management of multiple concurrent clients beyond the `broker` handling it internally. Tests with multiple clients (as suggested in one integration scenario) are important.
*   **High Global State Interaction:** Minimal global state observed in the application snippets themselves. The `startTime` in the client is instance-specific. The ErgoSockets `broker` and `client` instances hold significant internal state, but this is abstracted.
*   **Potential Resource Management Issues:**
    *   Client: `unsubscribeAnnouncements()` is deferred, which is good. Ensure all subscriptions and client connections are gracefully closed in a real application.
    *   Server: `http.ListenAndServe` is used. Graceful shutdown of the HTTP server is present in the server example. The ErgoSockets broker itself might need a `Shutdown(ctx)` method for cleaning up active WebSocket connections, which isn't explicitly called in the server example but would be crucial in production.
*   **Circular Dependencies Detected:** None detected within the provided application snippets or their direct usage of `shared_types`. Dependencies are `app -> library` and `app -> shared_types`.
*   **Refactoring Candidates:**
    *   Given the simplicity of the examples, no immediate refactoring candidates *within the application code* stand out. The design relies on the (assumed well-factored) ErgoSockets library. If the handlers within `server/main.go` or `client/main.go` were to grow significantly more complex, they would become candidates for extraction into separate functions/methods. *Refinement: Initially, I might look for complex functions. Here, the "complexity" is in the interaction patterns, which are handled by the library. The application code is clean due to this delegation.*


    Comprehensive Test Plan Specification (Generated via Recursive Self-Learning)
Generated: 2023-07-10T12:00:00Z
Codebase Language: Go
Analysis Scope: Full codebase static analysis with iterative refinement.

1. Executive Summary & Strategy
The WebSocketMQ library is a Go-based WebSocket messaging library that implements both request-response and publish-subscribe patterns over WebSockets. It consists of several key components:

Broker: Server-side component that manages WebSocket connections, subscriptions, and message routing
Client: Client-side component that connects to a WebSocket server and provides methods for making requests and subscribing to topics
Envelope: Message format used for communication
Shared Types: Application-specific message types and topic constants
The highest-risk areas based on iterative refined analysis are:

WebSocket Connection Management: The broker's handling of client connections, disconnections, and reconnections is critical and complex, with potential for resource leaks and race conditions.
Message Routing: The broker's ability to route messages to the correct handlers and clients is a core functionality with complex logic for handler registration and invocation.
Bidirectional Communication: The ability for both client-to-server and server-to-client requests introduces complexity in message handling and state management.
JavaScript Client Compatibility: Ensuring the library works with browser-based JavaScript clients is critical for its intended use but requires cross-language testing.
Error Handling and Recovery: The system's ability to handle errors and recover from failures is essential for robustness in real-world scenarios.
The testing strategy will focus on a balanced approach of unit, integration, and end-to-end tests, with special attention to JavaScript client tests. Initial analysis suggested a focus on unit tests for individual components, but deeper evaluation of cross-module dependencies revealed a need for more integration tests around the broker-client interaction and JavaScript client compatibility. The existing tests in broker_test.go provide good coverage of core functionality, but need to be expanded, particularly for JavaScript client testing.

For all tests, we will use real implementations instead of mocking, as specified in the requirements. Integration tests will use explicit synchronization with channels instead of sleeps to ensure deterministic behavior. JavaScript client tests will be implemented using go-rod for browser automation.

Limitations Note: This plan is based on static analysis and cannot cover runtime behavior, specific data edge cases not obvious from structure, or requirement mismatches. Performance characteristics under high load, long-term stability, and compatibility with all browser versions would require additional runtime testing beyond this plan.

2. Prioritized Unit Test Specifications
Target Entity: broker.Broker.OnRequest
Priority: Critical
Rationale: High effective complexity due to reflection-based handler registration and invocation. Initially ranked Medium based on signature alone, but elevated due to its central role in request handling and potential for runtime errors if handler signatures don't match expectations.
Suggested Test Cases/Scenarios:

Register a handler for TopicGetTime with correct function signature (happy path)
Register a handler for TopicUserDetails with correct function signature (base case)
Register a handler for an already registered topic (negative case - should return error)
Register a handler with invalid function signature (negative case - should return error)
Register a handler with non-pointer request type (edge case)
Register a handler with pointer request type (edge case) Mocking Needs: None, use real broker instance State Verification: Verify that handlers are correctly registered and can be invoked
Target Entity: broker.Broker.Publish
Priority: Critical
Rationale: High criticality due to its role in the publish-subscribe pattern. Moderate complexity due to message routing to multiple clients.
Suggested Test Cases/Scenarios:

Publish to a topic with one subscriber (happy path - subscriber should receive message)
Publish to a topic with no subscribers (base case - should not error)
Publish to a topic with multiple subscribers (all subscribers should receive message)
Publish with nil payload (edge case - should not error)
Publish with invalid payload (negative case - should return error) Mocking Needs: None, use real broker and client instances State Verification: Verify that messages are correctly delivered to subscribers using channels for synchronization
Target Entity: client.Client.Subscribe
Priority: Critical
Rationale: High criticality due to its role in the publish-subscribe pattern. Moderate complexity due to handler registration and message processing.
Suggested Test Cases/Scenarios:

Subscribe to a topic with valid handler (happy path)
Subscribe to a topic with nil handler (negative case - should return error)
Subscribe to a topic and then unsubscribe (base case)
Subscribe to multiple topics (edge case) Mocking Needs: None, use real client instance State Verification: Verify that subscription handlers are correctly registered and invoked using channels for synchronization
Target Entity: client.GenericRequest
Priority: Critical
Rationale: High criticality as it's the primary method for making requests. High complexity due to generic type handling and error processing.
Suggested Test Cases/Scenarios:

Make a request with no payload and receive response (happy path)
Make a request with a payload and receive response (base case)
Make a request that results in a server error (negative case - should return error)
Make a request that times out (negative case - should return error)
Make a request with invalid payload (edge case - should return error) Mocking Needs: None, use real client and broker instances State Verification: Verify that requests are correctly sent and responses are correctly processed
Target Entity: broker.ClientHandle.Request
Priority: High
Rationale: High criticality for server-initiated requests. Moderate complexity due to request-response handling.
Suggested Test Cases/Scenarios:

Make a request to a client and receive response (happy path)
Make a request with a payload and receive response (base case)
Make a request that results in a client error (negative case - should return error)
Make a request that times out (negative case - should return error) Mocking Needs: None, use real broker and client instances State Verification: Verify that requests are correctly sent to clients and responses are correctly processed using channels for synchronization
Target Entity: ergosockets.Envelope
Priority: Medium
Rationale: Medium criticality as it's the message format for all communication. Low complexity as it's primarily a data structure.
Suggested Test Cases/Scenarios:

Create an envelope with various types of payloads (happy path)
Decode payload into different types (base case)
Handle nil payload (edge case)
Handle error payload (negative case) Mocking Needs: None State Verification: Verify that payloads are correctly encoded and decoded
3. Prioritized Integration Test Specifications
Integration Point: Client-Server Request-Response
Priority: Critical
Entities Involved: client.Client, broker.Broker, app_shared_types.GetTimeRequest, app_shared_types.GetTimeResponse
Rationale: Critical interaction point as it tests the basic request-response pattern. High impact of failure as this is a core functionality.
Suggested Test Scenarios:

Client requests time from server and receives correct response (happy path)
Client requests time with timeout that succeeds (base case)
Client requests time with timeout that fails (negative case - timeout too short)
Multiple clients request time simultaneously (edge case) Key Interactions to Verify: Request envelope sent from client to server, handler invoked on server, response envelope sent from server to client
Integration Point: Server-Client Publish-Subscribe
Priority: Critical
Entities Involved: broker.Broker, client.Client, app_shared_types.ServerAnnouncement
Rationale: Critical interaction point as it tests the publish-subscribe pattern. High impact of failure as this is a core functionality.
Suggested Test Scenarios:

Server publishes announcement and client receives it (happy path)
Server publishes to multiple clients (base case)
Server publishes to a topic with no subscribers (edge case)
Client subscribes, receives message, then unsubscribes and doesn't receive (negative case) Key Interactions to Verify: Client subscription registered on server, publish message routed to subscribers, subscription handler invoked on client
Integration Point: Server-Client Request-Response
Priority: High
Entities Involved: broker.Broker, client.Client, broker.ClientHandle, app_shared_types.ClientStatusQuery, app_shared_types.ClientStatusReport
Rationale: High criticality as it tests server-initiated requests. Complex interaction involving broker getting client handle and making request.
Suggested Test Scenarios:

Server requests client status and receives correct response (happy path)
Server requests status with timeout that succeeds (base case)
Server requests status with timeout that fails (negative case - timeout too short)
Server requests status from disconnected client (negative case - should return error) Key Interactions to Verify: Request envelope sent from server to client, handler invoked on client, response envelope sent from client to server
Integration Point: Connection Management
Priority: High
Entities Involved: broker.Broker, client.Client
Rationale: High criticality as connection stability is essential. Complex interaction involving WebSocket connection establishment and maintenance.
Suggested Test Scenarios:

Client connects to server successfully (happy path)
Client disconnects gracefully (base case)
Client reconnects after disconnection (base case)
Broker detects client disconnection (edge case)
Broker handles slow clients (negative case - clients that don't read messages fast enough) Key Interactions to Verify: WebSocket connection established, ping-pong messages exchanged, disconnection detected, reconnection successful
Integration Point: Error Handling
Priority: Medium
Entities Involved: broker.Broker, client.Client, app_shared_types.ErrorTestRequest, app_shared_types.ErrorTestResponse
Rationale: Medium criticality as error handling is important for robustness. Moderate complexity in error propagation.
Suggested Test Scenarios:

Client makes request that triggers server error (happy path - error should be properly returned to client)
Server makes request that triggers client error (base case - error should be properly returned to server)
Client disconnects during request (negative case - server should handle gracefully)
Server shuts down during client request (negative case - client should handle gracefully) Key Interactions to Verify: Error messages correctly propagated, error handling doesn't crash components
4. Suggested End-to-End (E2E) Flow Specifications
E2E Flow: Full Client Lifecycle
Priority: High
Entry Point(s): client.Connect
Key Components Involved: client.Client, broker.Broker, all request and subscription handlers
Rationale: High criticality as it tests the complete workflow. Verifies that all components work together correctly.
Suggested Scenarios:

Client connects to server
Client requests time from server
Client requests user details from server
Client subscribes to server announcements
Server publishes announcement
Server requests client status
Client disconnects gracefully Configuration Dependencies: WebSocket server URL, request timeout, ping interval
E2E Flow: JavaScript Client Basic Integration
Priority: Critical
Entry Point(s): JavaScript client connect function
Key Components Involved: JavaScript client, broker.Broker, all request and subscription handlers
Rationale: Critical for ensuring browser compatibility, which is a key requirement. Initial analysis focused on Go client, but deeper evaluation revealed JavaScript client compatibility as a critical requirement.
Suggested Scenarios:

JavaScript client connects to server (happy path)
JavaScript client requests time from server (base case)
JavaScript client subscribes to server announcements (base case) Configuration Dependencies: WebSocket server URL, request timeout, ping interval
E2E Flow: JavaScript Client Advanced Integration
Priority: High
Entry Point(s): JavaScript client connect function
Key Components Involved: JavaScript client, broker.Broker, all request and subscription handlers
Rationale: High criticality for ensuring comprehensive browser compatibility.
Suggested Scenarios:

JavaScript client requests user details from server (happy path)
JavaScript client handles server requests for client status (base case)
JavaScript client requesting error test from server (negative case)
JavaScript client reconnecting after disconnection (edge case) Configuration Dependencies: WebSocket server URL, request timeout, ping interval
E2E Flow: Error Recovery
Priority: Medium
Entry Point(s): client.Connect with auto reconnect
Key Components Involved: client.Client, broker.Broker
Rationale: Medium criticality as it tests the system's ability to recover from failures.
Suggested Scenarios:

Client connects to server
Server is shut down
Client attempts to reconnect
Server is restarted
Client successfully reconnects
Client functionality resumes normally Configuration Dependencies: WebSocket server URL, reconnect settings
5. Regression Testing Scope Guidance
When modifying an entity, use the refined internal dependency map to identify all potentially affected upstream and downstream components. The priority for regression testing should be based on the refined criticality of the changed component and its dependents.

Example: If modifying the broker.Broker.handleClientRequest method, which is responsible for routing client requests to the appropriate handler, regression tests should focus on:

All request handler tests (both client-to-server and server-to-client)
Error handling tests
Integration tests for request-response patterns
6. Specific Areas Requiring Attention
Potential Test Coverage Gaps (Heuristic):

JavaScript client compatibility with different browsers
Long-term connection stability
Performance under high load
Resource leaks in long-running scenarios
High Global State Interaction:

Broker's client and subscription maps
Client's subscription handlers
Potential Resource Management Issues:

Goroutine leaks in long-running operations
WebSocket connection leaks if not properly closed
Channel deadlocks in request-response pattern
Circular Dependencies Detected:

None detected in the current codebase
Refactoring Candidates:

Broker's request handler registration and invocation could be simplified
Error handling and propagation could be more consistent
Connection management could be more robust
7. JavaScript Client Test Implementation Details
Test Structure
The JavaScript client tests should be organized into separate files for better organization:

js_client_connection_test.go: Tests for client connection and reconnection
js_client_request_test.go: Tests for client-to-server requests
js_client_subscribe_test.go: Tests for client subscriptions
js_client_handler_test.go: Tests for client request handlers
Each test file should include at least a negative test case, base case, and happy path case.

Test Implementation
For implementing these tests, the following approach is recommended:

Create a Test Page with JavaScript Client:
Create an HTML page that includes the JavaScript client library
Add JavaScript code to connect to the WebSocket server
Add JavaScript code to make requests, subscribe to topics, and handle server requests
Add UI elements to display results and interact with the client
Run a Server that Loads the JavaScript:
Create a test server that serves the HTML page
Configure the server to use the WebSocketMQ broker
Register the necessary request handlers on the broker
Use go-rod for Browser Automation:
Use go-rod to launch a browser and navigate to the test page
Use go-rod to interact with the page (click buttons, read text, etc.)
Use go-rod to verify that the client behaves as expected
Verify Functionality through Assertions:
Assert that the client connects successfully
Assert that requests receive the expected responses
Assert that subscriptions receive the expected messages
Assert that request handlers are invoked correctly
Helper Functions
Create the following helper functions to facilitate testing:

Test Setup Helpers:
setupTestServer(): Starts a test server with the WebSocketMQ broker
setupTestBrowser(): Launches a browser and navigates to the test page
waitForClientConnection(): Waits for the JavaScript client to connect to the server
Test Assertion Helpers:
assertClientConnected(): Asserts that the client is connected to the server
assertRequestResponse(): Asserts that a request receives the expected response
assertSubscriptionReceived(): Asserts that a subscription receives the expected message
Test Teardown Helpers:
teardownTestServer(): Shuts down the test server
teardownTestBrowser(): Closes the browser
Implementation Considerations
Test Setup:
Use a different port than 8080 for WebSocket connections (as specified in the requirements)
Use explicit synchronization with channels instead of sleeps
Use real implementations instead of mocking
Test Teardown:
Ensure browser is closed after tests
Ensure server is shut down after tests
Ensure all resources are properly cleaned up
Test Execution:
Use the -short flag to skip JavaScript client tests when running quick tests
Ensure tests can run automatically without requiring manual interaction
