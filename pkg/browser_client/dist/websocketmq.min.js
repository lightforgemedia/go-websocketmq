!function(e){"use strict";const t="request",o="response",s="publish",n="error",i="subscribe_request",r="unsubscribe_request",c="subscription_ack",l="system:register";class a{constructor(e={}){if(this.options=Object.assign({url:null,reconnect:!0,reconnectInterval:1e3,maxReconnectInterval:3e4,reconnectMultiplier:1.5,defaultRequestTimeout:1e4,clientName:"",clientType:"browser",clientURL:"undefined"!=typeof window?window.location.href:"",logger:console,updateURLWithClientID:!0},e),!this.options.url)throw new Error("WebSocketMQ: URL is required");this.ws=null,this.isConnected=!1,this.isConnecting=!1,this.reconnectAttempts=0,this.reconnectTimer=null,this.explicitlyClosed=!1,this.id=this._extractClientIDFromURL()||this._generateID(),this.pendingRequests=new Map,this.subscriptionHandlers=new Map,this.requestHandlers=new Map,this.onConnectCallbacks=new Set,this.onDisconnectCallbacks=new Set,this.onErrorCallbacks=new Set,this._onMessage=this._onMessage.bind(this),this._onOpen=this._onOpen.bind(this),this._onClose=this._onClose.bind(this),this._onError=this._onError.bind(this)}connect(){if(this.isConnected||this.isConnecting)this.options.logger.debug("WebSocketMQ: Already connected or connecting.");else{this.isConnecting=!0,this.explicitlyClosed=!1,this.options.logger.debug("WebSocketMQ: Connecting to",this.options.url);try{let e=this.options.url;const t=new URL(e,window.location.href);t.searchParams.set("client_id",this.id),this.ws=new WebSocket(t.toString()),this.ws.addEventListener("open",this._onOpen),this.ws.addEventListener("message",this._onMessage),this.ws.addEventListener("close",this._onClose),this.ws.addEventListener("error",this._onError)}catch(e){this.isConnecting=!1,this._handleError(e),this.explicitlyClosed||this._scheduleReconnect()}}}disconnect(){if(this.options.logger.debug("WebSocketMQ: Disconnect called."),this.explicitlyClosed=!0,clearTimeout(this.reconnectTimer),this.reconnectTimer=null,this.ws)try{this.ws.close(1e3,"Client disconnected")}catch(e){}}request(e,o=null,s=null){if(!this.isConnected)return this.options.logger.warn("WebSocketMQ: Not connected. Cannot send request."),Promise.reject(new Error("WebSocketMQ: Not connected"));const n=s||this.options.defaultRequestTimeout;return new Promise(((s,i)=>{const r=this._generateID(),c=setTimeout((()=>{this.pendingRequests.has(r)&&(this.pendingRequests.delete(r),i(new Error(`WebSocketMQ: Request to '${e}' timed out after ${n}ms`)))}),n);this.pendingRequests.set(r,{resolve:e=>{clearTimeout(c),s(e)},reject:e=>{clearTimeout(c),i(e)}}),this._sendEnvelope({id:r,type:t,topic:e,payload:o}).catch((e=>{clearTimeout(c),this.pendingRequests.delete(r),i(e)}))}))}publish(e,t=null){return this.isConnected?this._sendEnvelope({id:"",type:s,topic:e,payload:t}):(this.options.logger.warn("WebSocketMQ: Not connected. Cannot publish."),Promise.reject(new Error("WebSocketMQ: Not connected")))}subscribe(e,t){if("function"!=typeof t)throw new Error("WebSocketMQ: Handler must be a function");return this.subscriptionHandlers.set(e,t),this.isConnected&&this._sendSubscribeRequest(e).catch((t=>{this.options.logger.error(`WebSocketMQ: Error subscribing to topic '${e}':`,t)})),()=>{this.subscriptionHandlers.delete(e),this.isConnected&&this._sendUnsubscribeRequest(e).catch((t=>{this.options.logger.error(`WebSocketMQ: Error unsubscribing from topic '${e}':`,t)}))}}onRequest(e,t){if("function"!=typeof t)throw new Error("WebSocketMQ: Handler must be a function");return this.requestHandlers.set(e,t),()=>{this.requestHandlers.delete(e)}}onConnect(e){return"function"==typeof e&&(this.onConnectCallbacks.add(e),this.isConnected&&e()),()=>this.onConnectCallbacks.delete(e)}onDisconnect(e){return"function"==typeof e&&this.onDisconnectCallbacks.add(e),()=>this.onDisconnectCallbacks.delete(e)}onError(e){return"function"==typeof e&&this.onErrorCallbacks.add(e),()=>this.onErrorCallbacks.delete(e)}getID(){return this.id}_onOpen(e){this.isConnected=!0,this.isConnecting=!1,this.reconnectAttempts=0,this.options.logger.info("WebSocketMQ: Connected."),this._sendRegistration(),this.onConnectCallbacks.forEach((t=>{try{t(e)}catch(e){this.options.logger.error("Error in onConnect callback",e)}}))}_onClose(e){const t=this.isConnected;this.isConnected=!1,this.isConnecting=!1,this.options.logger.info("WebSocketMQ: Disconnected. Code:",e.code,"Reason:",e.reason,"WasClean:",e.wasClean),t&&this.onDisconnectCallbacks.forEach((t=>{try{t(e)}catch(e){this.options.logger.error("Error in onDisconnect callback",e)}})),!this.explicitlyClosed&&this.options.reconnect&&this._scheduleReconnect()}_onError(e){const t=e instanceof Error?e:new Error("WebSocket error");this.options.logger.error("WebSocketMQ: Error:",t,"Raw event:",e),this.onErrorCallbacks.forEach((o=>{try{o(t,e)}catch(e){this.options.logger.error("Error in onError callback",e)}}))}_onMessage(e){let i;try{i=JSON.parse(e.data),this.options.logger.debug("WebSocketMQ: Received message:",i)}catch(t){return void this._handleError(new Error(`WebSocketMQ: Failed to parse message: ${t.message}. Data: ${e.data}`))}switch(i.type){case o:case n:this._handleResponseEnvelope(i);break;case s:this._handlePublishEnvelope(i);break;case t:this._handleRequestEnvelope(i);break;case c:this.options.logger.debug(`WebSocketMQ: Received subscription ack for topic '${i.topic}'`);break;default:this.options.logger.warn(`WebSocketMQ: Received unknown message type: ${i.type}`)}}_handleResponseEnvelope(e){const t=e.id;if(!t)return void this.options.logger.warn("WebSocketMQ: Received response without ID:",e);const o=this.pendingRequests.get(t);if(o)if(this.pendingRequests.delete(t),e.type===n)o.reject(new Error(e.error?e.error.message:"Unknown error"));else{let t=null;try{t=e.payload?JSON.parse(e.payload):null}catch(e){return void o.reject(new Error(`Failed to parse response payload: ${e.message}`))}o.resolve(t)}else this.options.logger.warn(`WebSocketMQ: Received response for unknown request ID: ${t}`)}_handlePublishEnvelope(e){const t=e.topic,o=this.subscriptionHandlers.get(t);if(o){let s=null;try{s=e.payload?JSON.parse(e.payload):null}catch(e){return void this.options.logger.error(`WebSocketMQ: Failed to parse publish payload for topic '${t}':`,e)}try{o(s)}catch(e){this.options.logger.error(`WebSocketMQ: Error in subscription handler for topic '${t}':`,e)}}else this.options.logger.debug(`WebSocketMQ: No handler for published message on topic: ${t}`)}_handleRequestEnvelope(e){const t=e.topic,s=this.requestHandlers.get(t);if(s){let i=null;try{i=e.payload?JSON.parse(e.payload):null}catch(o){return this.options.logger.error(`WebSocketMQ: Failed to parse request payload for topic '${t}':`,o),void this._sendEnvelope({id:e.id,type:n,topic:e.topic,error:{code:400,message:`Failed to parse request payload: ${o.message}`}})}try{Promise.resolve(s(i)).then((t=>{this._sendEnvelope({id:e.id,type:o,topic:e.topic,payload:t})})).catch((t=>{this._sendEnvelope({id:e.id,type:n,topic:e.topic,error:{code:500,message:t.message||"Handler error"}})}))}catch(o){this.options.logger.error(`WebSocketMQ: Error in request handler for topic '${t}':`,o),this._sendEnvelope({id:e.id,type:n,topic:e.topic,error:{code:500,message:o.message||"Handler error"}})}}else this.options.logger.warn(`WebSocketMQ: No handler for server-initiated request on topic: ${t}`),this._sendEnvelope({id:e.id,type:n,topic:e.topic,error:{code:404,message:`No handler registered for topic: ${t}`}})}_sendRegistration(){const e={clientID:this.id,clientName:this.options.clientName||`browser-${this.id.substring(0,8)}`,clientType:this.options.clientType||"browser",clientURL:this.options.clientURL||window.location.href};this.request(l,e).then((e=>{e&&e.serverAssignedID&&(this.options.logger.info(`WebSocketMQ: Server assigned new ID: ${e.serverAssignedID}`),this.id=e.serverAssignedID,this._updateURLWithClientID(),this._resubscribeAll())})).catch((e=>{this.options.logger.error("WebSocketMQ: Registration failed:",e)}))}_resubscribeAll(){if(this.subscriptionHandlers.size>0){this.options.logger.info(`WebSocketMQ: Re-subscribing to ${this.subscriptionHandlers.size} topics...`);for(const e of this.subscriptionHandlers.keys())this._sendSubscribeRequest(e).catch((t=>{this.options.logger.error(`WebSocketMQ: Error re-subscribing to topic '${e}':`,t)}))}}_sendSubscribeRequest(e){return this._sendEnvelope({id:this._generateID(),type:i,topic:e})}_sendUnsubscribeRequest(e){return this._sendEnvelope({id:this._generateID(),type:r,topic:e})}_sendEnvelope(e){return new Promise(((t,o)=>{if(this.isConnected&&this.ws&&this.ws.readyState===WebSocket.OPEN)try{null!==e.payload&&"string"!=typeof e.payload&&(e.payload=JSON.stringify(e.payload)),this.ws.send(JSON.stringify(e)),this.options.logger.debug("WebSocketMQ: Sent envelope:",e),t()}catch(e){this._handleError(e),o(e)}else o(new Error("WebSocketMQ: Not connected or WebSocket not open"))}))}_scheduleReconnect(){if(this.explicitlyClosed||!this.options.reconnect||this.reconnectTimer)return;this.reconnectAttempts++;const e=Math.min(this.options.reconnectInterval*Math.pow(this.options.reconnectMultiplier,this.reconnectAttempts-1),this.options.maxReconnectInterval);this.options.logger.info(`WebSocketMQ: Scheduling reconnect attempt ${this.reconnectAttempts} in ${e}ms.`),this.reconnectTimer=setTimeout((()=>{this.reconnectTimer=null,this.explicitlyClosed||this.connect()}),e)}_generateID(){return Date.now().toString(36)+Math.random().toString(36).substring(2,10)}_extractClientIDFromURL(){if("undefined"==typeof window)return null;return new URLSearchParams(window.location.search).get("client_id")}_updateURLWithClientID(){if("undefined"!=typeof window&&this.options.updateURLWithClientID&&window.history&&window.location)try{const e=new URL(window.location.href),t=new URLSearchParams(e.search);t.set("client_id",this.id),e.search=t.toString(),window.history.replaceState({},"",e.toString()),this.options.logger.debug(`WebSocketMQ: Updated URL with client ID: ${this.id}`)}catch(e){this.options.logger.error(`WebSocketMQ: Failed to update URL with client ID: ${e.message}`)}}_handleError(e){this.options.logger.error("WebSocketMQ: Error:",e),this.onErrorCallbacks.forEach((t=>{try{t(e)}catch(e){this.options.logger.error("Error in onError callback",e)}}))}}"undefined"!=typeof module&&void 0!==module.exports?module.exports={WebSocketMQClient:a,TYPE_REQUEST:t,TYPE_RESPONSE:o,TYPE_PUBLISH:s,TYPE_ERROR:n,TYPE_SUBSCRIBE_REQUEST:i,TYPE_UNSUBSCRIBE_REQUEST:r,TYPE_SUBSCRIPTION_ACK:c,TOPIC_CLIENT_REGISTER:l}:e.WebSocketMQ={Client:a,TYPE_REQUEST:t,TYPE_RESPONSE:o,TYPE_PUBLISH:s,TYPE_ERROR:n,TYPE_SUBSCRIBE_REQUEST:i,TYPE_UNSUBSCRIBE_REQUEST:r,TYPE_SUBSCRIPTION_ACK:c,TOPIC_CLIENT_REGISTER:l}}("undefined"!=typeof self?self:this);